{"meta":{"title":"aenjon","subtitle":null,"description":"aenjon Burning Life","author":"aenjon","url":"http://aenjon.com"},"pages":[{"title":"","date":"2016-11-24T09:17:45.000Z","updated":"2016-05-14T02:32:12.000Z","comments":true,"path":"tail.html","permalink":"http://aenjon.com/tail.html","excerpt":"","keywords":null,"text":"版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/tail.html","raw":null,"content":null},{"title":"Tags","date":"2016-11-24T09:17:45.000Z","updated":"2015-11-26T16:01:34.000Z","comments":true,"path":"tags/index.html","permalink":"http://aenjon.com/tags/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"Solutions","date":"2015-12-30T15:21:20.000Z","updated":"2016-10-15T13:19:12.000Z","comments":true,"path":"solutions/index.html","permalink":"http://aenjon.com/solutions/index.html","excerpt":"","keywords":null,"text":"定制开发Android AppiOS AppTV App(Android)图像算法 解决方案NFC/RFID城市一卡通/智慧城市智慧停车无线互联/多屏互动 联系我Email： skyserpah00@163.com（合作交流） 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/solutions/index.html","raw":null,"content":null},{"title":"Projects","date":"2015-12-30T15:21:20.000Z","updated":"2016-12-08T00:21:25.000Z","comments":true,"path":"projects/index.html","permalink":"http://aenjon.com/projects/index.html","excerpt":"","keywords":null,"text":"前传 这个页面主要对本人完成或参与完成的部分项目进行规整，主观的将其分为智能硬件、图像算法和TV/移动应用(Android/iOS)三大项，每项以时间为序进行逆向排列，其中某些领域研究较多以专题的形式呈现，如NFC/RFID专题，我的开源，目前只整理了小部分，这是一个长期过程，后续逐一补全。 部分项目有原理或源码分享，请在aenjon博客翻找。 欢迎您告诉我您的任何想法或需求，或者有什么好点子我能帮上忙的也可以与我联系，联系方式见文末。 智能硬件待补充… 图像算法OCR文字识别… 手掌手指分割算法该算法是2014年时为朋友一家公司做指纹识别做的一套手掌分割手指的算法，可以很好的识别出白天/黑夜场景下摄像头拍照手掌图片分割后获取手指指纹图片输入给指纹识别，更多介绍请参考此文（含核心源码），运行效果如下如： 织物瑕疵检测系统该软件是2011年研究生生涯的研究课题，“织物疵点检测机器视觉系统研究”，算法+软件+系统，涉及两篇核心算法学术论文，软件平台基于Visual Studio2010 + OpenCV2.1，单张图片总耗时为241~278 ms，更多介绍请参考此文，其中关于显著性算法的实践效果请参考此文，软件效果如下： 彩色图像分析软件该软件是2010年在国内一家大型停车诱导公司做车位识别算法时对彩色图像的专题研究整理出的一套彩色图像分析软件，部分原理可参考此文，软件介绍请参考此文，软件效果如下： 停车场车位检测算法该算法是2010年给国内一家大型停车诱导公司基于彩色图像的研究的车位识别算法，暂不便公开说明。 TV应用(Android)手势控制 多屏互动/nScreen 360应用市场豌豆荚 家庭云/FamilyCloud T-CAST 悬浮球该应用曾与极简电视一起参加美国2013 CES展 …… 还有很多，后面继续补充。。。。 移动应用(Android/iOS)NETS MConnect(iOS/Android) Apple NetTest(Android)蒲公英 SmartParking(Android)…… 太多，待以后一一补充… NFC/RFID专题某省会城市一卡通项目 碰碰米 应用宝360应用市场豌豆荚小米应用商店蒲公英 极控者智能戒指 Google-Play应用宝360应用市场豌豆荚蒲公英 NFC云分享 应用宝360应用市场豌豆荚 NFC任务管理 应用宝360应用市场豌豆荚 TV NFC控制该项目曾参加德国2013 IFA展 《Android NFC开发详解》2013年撰写， 国内第一本Android NFC书籍，版权输出宝岛台湾，更多详情请参考此文 我的开源 nfc_wifi_assistant Android NFC Wifi Auto Connect TopAppMonitor Android前台应用监测 PlistAutoCreate iOS plist和OTA 自动生成脚本 更多待补充… 其它待补充… 后记 联系我Email： skyserpah00@163.com（合作交流） Update time08/31/2016 Update,add nfc06/12/2016 Update,add TV App11/30/2015 Create this page 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/projects/index.html","raw":null,"content":null},{"title":"Products","date":"2015-12-30T15:21:20.000Z","updated":"2016-08-09T13:49:32.000Z","comments":true,"path":"products/index.html","permalink":"http://aenjon.com/products/index.html","excerpt":"","keywords":null,"text":"前传 这个页面主要对个人完成的部分项目进行规整，主观的将其分为智能硬件、图像算法和TV/移动应用(Android/iOS)三大项，每项以时间为序进行逆向排列，其中某些领域研究较多以专题的形式呈现，如NFC/RFID专题，我的开源，目前只整理了小部分，这是一个长期过程，后续逐一补全。 部分项目有原理或源码分享，请在aenjon博客翻找。 欢迎您告诉我您的任何想法或需求，或者有什么好点子我能帮上忙的也可以与我联系，联系方式见文末。 智能硬件待补充… 图像算法OCR文字识别… 手掌手指分割算法该算法是2014年时为朋友一家公司做指纹识别做的一套手掌分割手指的算法，可以很好的识别出白天/黑夜场景下摄像头拍照手掌图片分割后获取手指指纹图片输入给指纹识别，更多介绍请参考此文（含核心源码），运行效果如下如： 织物瑕疵检测系统该软件是2011年研究生生涯的研究课题，“织物疵点检测机器视觉系统研究”，算法+软件+系统，涉及两篇核心算法学术论文，软件平台基于Visual Studio2010 + OpenCV2.1，单张图片总耗时为241~278 ms，更多介绍请参考此文，其中关于显著性算法的实践效果请参考此文，软件效果如下： 彩色图像分析软件该软件是2010年在国内一家大型停车诱导公司做车位识别算法时对彩色图像的专题研究整理出的一套彩色图像分析软件，部分原理可参考此文，软件介绍请参考此文，软件效果如下： 停车场车位检测算法该算法是2010年给国内一家大型停车诱导公司基于彩色图像的研究的车位识别算法，暂不便公开说明。 TV应用(Android)手势控制 多屏互动/nScreen 360应用市场豌豆荚 家庭云/FamilyCloud T-CAST 悬浮球该应用曾与极简电视一起参加美国2013 CES展 …… 还有很多，后面继续补充。。。。 移动应用(Android)NetTest… SmartParking… 移动应用(iOS)待补充… NFC/RFID专题极控者智能戒指 Google-Play应用宝360应用市场豌豆荚 NFC云分享 应用宝360应用市场豌豆荚 NFC任务管理 应用宝360应用市场豌豆荚 TV NFC控制该项目曾参加德国2013 IFA展 Android NFC开发详解2013年撰写， 国内第一本Android NFC书籍，版权输出宝岛台湾，更多详情请参考此文。 我的开源 nfc_wifi_assistant Android NFC Wifi Auto Connect TopAppMonitor Android前台应用监测 PlistAutoCreate iOS plist和OTA 自动生成脚本 更多待补充… 其它待补充… 后记 联系我Email： skyserpah00@163.com（合作交流） 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/products/index.html","raw":null,"content":null},{"title":"Favorite","date":"2015-12-30T15:21:20.000Z","updated":"2016-05-29T02:40:52.000Z","comments":true,"path":"favorite/index.html","permalink":"http://aenjon.com/favorite/index.html","excerpt":"","keywords":null,"text":".hexo-image-steam-lazy {display:block;}.hexo-img-stream{width:90%;max-width:1100px;margin:3% auto}div.hexo-img-stream figure{background:#fefefe;box-shadow:0 1px 2px rgba(34,25,25,0.4);margin:0 0.05% 3%;padding:3%;padding-bottom:10px;display:inline-block;max-width:25%}div.hexo-img-stream figure img{border-bottom:1px solid #ccc;padding-bottom:15px;margin-bottom:5px}div.hexo-img-stream figure figcaption{font-size:.9rem;color:#444;line-height:1.5;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}div.hexo-img-stream small{font-size:1rem;float:right;text-transform:uppercase;color:#aaa}div.hexo-img-stream small a{color:#666;text-decoration:none;transition:.4s color}@media screen and (max-width:750px){.hexo-img-stream{column-gap:0}}创业维坚 高效能人士的七个习惯 Android NFC开发实战详解 愤怒的小鸟 疯狂动物城 Star Wars: The Force Awakens House of Cards Season 4 $('img.hexo-image-steam-lazy').lazyload({ effect:'fadeIn' }); 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/favorite/index.html","raw":null,"content":null},{"title":"Categories","date":"2016-11-24T09:17:45.000Z","updated":"2015-11-26T16:01:34.000Z","comments":true,"path":"categories/index.html","permalink":"http://aenjon.com/categories/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"About","date":"2015-11-30T15:21:20.000Z","updated":"2016-12-11T01:24:55.000Z","comments":true,"path":"about/index.html","permalink":"http://aenjon.com/about/index.html","excerpt":"","keywords":null,"text":"About MeWelcome to aenjon‘s site which created: 11/30/2015. and before in cnBlogs / CSDN BABA 资深软件工程师 某企业培训机构 企业内训高级讲师 某在线教育平台 Android讲师 关注（Focus） 移动开发（Android/iOS） 无线互联/多屏互动（NFC/RFID/nScreen/DLNA/Mirrcast/…） 图像识别/机器视觉(OpenCV/彩色图像分割/图像特征/瑕疵检测/OCR/…) AR/VR/3D打印(OpenGL/…) 产品设计 敏捷开发(敏捷思维/Scrum/…) 一些作品（Product）我的项目我的著作待补充… 我的演讲待补充… 更多了解（More）About meGitHubcnBlogsWeiboFacebookGoogle+ZhiHuDouBanGitBook 联系我（Contact Me）Email： skyserpah00@126.com（合作交流）公众号： aenjon 查看我的简历…待补充… 了解我的发展…待补充… 二维码 Update time05/12/2016 Update QR code11/30/2015 Create 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/about/index.html","raw":null,"content":null}],"posts":[{"title":"而立之年，未开始的创业路","slug":"aenjon/Life/而立之年，未开始的创业路","date":"2016-10-30T16:30:30.000Z","updated":"2016-12-11T15:41:58.000Z","comments":true,"path":"2016/10/31/aenjon/Life/而立之年，未开始的创业路/","link":"","permalink":"http://aenjon.com/2016/10/31/aenjon/Life/而立之年，未开始的创业路/","excerpt":"","keywords":null,"text":"题记“现代人不是渴望成功，而是渴望马上成功。” 前几天同一个创客类培训机构合伙人就合作事宜巴拉吧啦，一句话刺激到了小小的心脏，加上90后创业者的遍地开花🌼，似乎些许浮躁，香菇难受，辗转反侧，诸多思考，有了此文。 A君先从这位创业者（简称A君）说起吧。A，一位87年小伙，13年研究生毕业后校招进鹅厂，14年深圳宝安2w- 买了房解决了第一个生存问题，15年在一个老板给的200w启动资金下，与几个同事还有以前的同学一起创业，路演获取前海梦工厂创意园办公基地免费入驻…他想让我加入他们培训体系中某个领域所谓的“权威人士”， 录制线上视频并兼线下培训高级讲师，与我之前合作过的几家大型线上/线下培训机构不同，聊天中他一味的强调他们平台多么多么N，可以将我包装成这个领域绝对的权威，签署排他协议，可以通过他们平台获得很好的声誉，还可以在它们的专栏中出售自己书籍/作品，当报名学员比较多时组织线下培训，培训费用以某个比例分成巴拉巴拉…说白了，没有实际利益，大饼的方式加上我个人时间确实差不多饱和，所以当场直接婉拒了。然后继续聊他们的创业，讨论了一些关于创业的观点，巴拉巴拉，然后谈到我自己时，我说我的创业路一定会前行，但现在想先满足或者说解决部分生活上的财务自由再开始…他给我一句话刺到了我，“创业的话，真的不年轻了…”，然后提到他们公司现在招聘的都是90后，93/94年小伙子，有冲劲，技术也不错，Github上开源项目star也众多…面试时问 “大家技术都不错，相比别人，我们为什么要录用你而不是别人？”，”年轻资本，熬夜资本…” 这样的答复A自己都笑了，确实很现实，创业公司不多一份付出也不现实（说的有点委婉了），熬夜我们肯定熬不过他们年轻人，这是他们的资本，就如现在邀请我作为他们讲师也一样，这个领域让这群90后去啃，给一定的时间也完全不会有问题，他希望可以找一个既有地位的人来负责比较好（真厉害又被绕进去了）…后面还聊了很多，交换了微信和名片，嘱咐不要急着给答复回去权衡思考下，同他们一起把这件事有意义的事干一干…巴拉巴拉，又一大堆，这些都不重要了，我的思维还停留在他前面的那句话，“创业的话，真的不年轻了…”，是的，打算创业，30，而立之年，创业还未真正开始，慌？盲？迟？ 创业，真的想清楚了？ 聊聊周围B君，大学同学，14年离职后同三个同事创立了一家停车场相关公司，自己负责技术，其它三个负责资金和市场，股份平均（创业禁忌）。他们四人每人每月6k生活补贴，其它所有资金都作为储备资金，风风火火的干了一年，团队也从四人做到了十来个，月账面流水也从几万到几十万。15年，B选择退出，以股份比例分到了一大笔钱。自己注册了另外一家公司，还是做原来的产品，跑华强北购买元器件，找PCB板商画板贴片再招人包装，然后跑市场积累客户，一年多下来，毛收入做到了200w。现在的他，每天就是进货出货，跑跑市场谈谈主要客户，自由时间大把大把的，每天打打球陪陪小孩，从来没有10点前起过床，也经常找我聊聊是否有其它扩展门路，结合互联网如何来做巴拉巴拉…说说他这个产品吧，很简单的一个小硬件产品，停车远距离刷卡，读头+卡片，主要赚取卡片插差价。14年15年很多次跟我聊天，说心里话，我压根就看不起这样的产品，这样的所谓“创业”，我跟他聊天灌输的思想一定是高大上的，一定是平台级的，一定是结合互联网，一定是大大的XX。现在，我会发现，错了，我有很多很多很好ideal，我有很好的互联网思维，我拥有技术，但创业或许是个伪命题，只是一个概念，那时的我纯粹的认为创业真的只是一种情怀，是为了情怀，从来没考虑过商业化的思想，突然感觉好像错了，创业，谈情怀之前先谈利益，赚到钱了能盈利才是企业，才是创业，才是中国现社会追从的成功人生。 是么？ C君，同校师兄，08年毕业来到深圳，从SCM到DSP到ARM，从普通工程师到现在某企业（中小企业，100多号人）总技术负责人，拥有企业的股份。他没有所谓的创业，但却能实现100w+的年收入，当然，单纯工作工资肯定没这么多，他在很早时通过别人介绍认识了他现在做的这个行业中某位台湾老板，当时完全不计较得失没日没夜的给他绘图做板开发，最终成为了长期合作伙伴维持并到现在，他们的产品在台北市拥有近乎1/3的市场…是的，他以工作和兼职的方式也在深圳立足下来，农村出生，今年（2016年喔）在深圳南山刚换了第二套房。 每次跟他爬塘朗山，聊天中会发现他是那种慢性子，做事有条不紊，绝不会去追求冒险。我不止一次问他为什么不创立一家公司，招一点人把事做大，他每次都笑一笑说道，成立公司又能怎么样呢？能赚的更多么？ 当时不理解，觉得太势利，目光看不远，只在乎短期利益，现在想想，其实也不然，雄浑大志之前一定也要脚踏实地，现在大多数互联网创业者，用所谓的互联网思维去创业，成天谈的就是融资圈钱甚至上市，通过融资去圈用户，然后再考虑如何盈利，是的动辄几百万甚至上千万融资（独角兽类公司毕竟是少数，我们需要那样的实例和憧憬，但短期还是先从产品做起），自身也华丽转身，转身之后呢？我希望的创业也是就酱紫的？ D君，初中同学，未读大学，职高毕业就来到了南广州，从事会展相关设计工作，前面和行业一个朋友一起成立了一家会展相关公司，承办国内外中小型会展设计与布展，目前公司十多个人，一部分是设计师，公司每年也有好几百w的毛收入。我们聚的不是很多，寥寥几次都是记忆深刻，总是带着我出入一些作为码农不太可能涉入的场合，such as夜总会、酒吧、棋牌室等，一群人聊的除了生意就是女人…这也是身边的一个创业者，有可以自己赖以生存的小公司，用他自己的话说反正比打工强。 … 是的，上面介绍的都是身边的熟人朋友，做的事并不是纯互联网，或实业或者硬件相关，或许他们观点不太正确，甚至有点out，有点跟不上或者脱离我们现在吹的天花乱坠的互联网+的时代，但是，他们至少在他的那领域暂时可以说是成功的，获取了财富，获得了自己想要的，还有自由之身。当然，我周边也有一些互联网创业朋友，天天谈创业，谈融资，天天吹，很多都处在或惆怅融资或惆怅产品阶段，对此不评价… 这两年的一面之缘这两年有太多创业者找我聊天，有过太多一面之缘，微信上有近乎150+个创业者信息，或创始人或CEO或CTO或合伙人或投资者。看了很多项目，聊了很多项目，也更加发现项目本身真的不那么重要，创业也真的想象中的那么高大上，简单聊聊几个。 E君，一家传统行业的老板，有过行业多次创业经验，15年辞职到现在的公司任执行总裁，创始人是拥有多个摄影基地，拥有雄厚资本，一起创立的公司天使轮就2000w的融资，租赁了比较豪华奢侈有讲究的office，每次过去都是会在他们奢侈办公室喝茶聊项目，然后晚上入驻酒店。我给他们做了几个月的技术负责人，虽然一直要求我去全职入职做他们的技术总监/CTO，综合考虑后最终还是婉拒了。谈谈这个公司吧，才开始技术（双端App+服务端+Web页+公众号 全平台）是外包的，我加入的时候外包已经开始了，我跟进时发现外包公司技术很low，有点忽悠的感觉，招聘应届生来写不熟悉的代码。后面为了进度（定在某个时间需要新闻发布会，准备A轮融资），采取了一方面外包开发继续，一方面组建自己的技术团队，然后再通过自己技术团队逐步将外包可用代码和需求迭代过来，整个过程还是挺艰辛的，最终产品稍许delay后基本按期凑合发布了（发布前一晚还在熬夜赶业务调整需求，没法留出时间做任何性能或质量上的测试等等）。其实按道理说这是一个很不错的经历，团队是我自己组建的，各方面都还不错，但中间过程中我逐渐发现，总监E和Boss都是传统行业人，都不懂技术而且都不太重视技术，他们眼里技术只是为了完成他们这个App或者某个功能，很多时候沟通起来真费劲甚至有些可笑，我的那只团队成员中间近乎3个月没怎么休息过（有一个月全月都在工作，团队成员都单独找我私聊，我用各种理由把E说服后，后面才好些），每天加班赶需求改需求，纵然我给他们挡了很多，给E立了很多项目规范，建立需求池，培训敏捷迭代开发…但，很多都只是暂时的，很难建立一套真正的互联网化敏捷化的项目过程，甚至都很难以项目的方式推进…整个过程下来逐渐发现其实这不是自己想要的创业，想要的事业，想要的一起奋斗的团队，加入后也不会有太大改观，领导的思维很重要，有些固有思维几乎是不可该改变的，确实，纵然，资金+资源这块是E公司最大的优势（这也是我见了几十家创业公司中资源和资本最充足的），但拼凑的团队以及太多传统行业的束缚以及对技术的不重视，会觉得这家企业不会走很长远，不会做的足够大，这是我当时的判断。现在这家公司线下还是做的火热火热的（整合和合作了众多线下一线品牌加盟商），几个月了线上却还只有几千的用户量，日活也少的可怜，比起我自己做的一些App都少很多。是的，创业，团队和资源同样重要，创始人的思维更重要，有什么的思维注定了可以你的团队，你的企业，你的事业可以走多远，所以，创业者的思维，你准备好了么？ F君，一家3D打印平台的CEO/创始人，她在这个行业一直做了近20年，对整个相关联的实体了解颇深（3D打印商等），也正好赶上习大大的一带一路政策，所以就夫妻一起在14年底注册了这家公司来做这样一个平台，深受当地政府的厚重（跟我聊天时将她与市长的微信聊天记录给我看，展览时国家部级领导人参观交流的照片等），政府免费提供了一层楼给其办公，公司人员就十来个，融了两次资（私人老板），第一次200w，10%的股份；第二次200w，5%的股份。 我们见了两次面，一次是她来我上班的地方，咖啡馆里简单聊了两个小时，第二次是在15年底，她公司的城市，我们聊了一整天，上午在其办公室，中午餐馆，下午办公室园区，一直再聊。个人直觉对这样一个行业，领域是非常的看好和认同，CEO眼光也不错，内心希望加入（回家后还跟媳妇商量了好久），但最终没有去成，败在现实利益面前。我们后面邮件往来了很多次主要是沟通待遇利益问题，CTO职位，她最终能给的股份期权非常有限，而且受限很大（不是一次性给），而工资就很少了，基本就是万把块钱的基本生活费，考虑到当时自己的情况，纠结了好久最后选择了放弃。这是自己现在回想会觉得有丝许后悔的为数不多一件事，其实，那时的我也不懂什么创业不创业，仅仅是凭自己的直觉，认为这件事可以为之，认可这样一个领域和产品，却败给了现实的自己。 现在的我反思，总结出创业最最重要的一点，是你必须认可这样一件事，这样才能全身心有激情的去当作自己的事业奋斗，但，同时，创业之路是有风险的，不可能考虑太多现实物质基础的，这样，你真的准备好了么？ G君，应该是一位富二代，从他第二次深夜里开着加长版大奔（恕我浅薄，第一次在深圳见到）来我住的地方判断的（当时车上还坐着一位美女，然后犹豫找不着停车位就让她在车上等着，我俩找了个小店深聊到凌晨1点多）。他从事的是银行放贷这一块的，手里有很多资源，已经有好几家公司，他想做一个放贷相关的金融平台，然后提到马云，然后巴拉巴拉…后面又跟我聊了很多金融相关的东东，包括谈到很多现实的问题，例如在深圳没房，他说保证我明年不出一分钱拥有一套房，具体如何通过资本运作获得跟我详细讲了，听的我云里雾里…是的，他是玩资本的，而且玩了很多年了，国内外资本兼备，对金融完全陌生的我对他有些感到害怕（实话说长这么大还没具体说害怕过某个人）和胆怯…他要求我立即辞职，第二天就去他高大上办公室开始干起，具体他要做的事我都事晕的没有思考的余地，针对马上辞职这个观点，我试着辩解说这不太可能，他马上说提供高额补贴，巴拉巴拉…感觉在他面前我完全没有任何话语权，这是我长这么大从来没有遇到的事…我当时只好回复说要回去同媳妇商量下再决定，当然最后还是没去。 后面和一些朋友聊到这事，他们都说我的抉择是正确的，至少我认为，对于创业，至少要在你熟悉的领域进行，完全陌生的领域，虽然你只需要负责技术，但这不应该叫创业，所以，创业，这个领域你熟悉么？（ps，现在朋友圈看到G经常晒各种照片，非常成功，各种投资，上月还看到其参加第十一届中国中小企业企业家创新发展大会中拿奖…只能说是一枚有魄力有资本有资源的领导者，服…只是资本的世界现在的我真的不懂～） H君，没见过面但留有印象，外包做了一个智慧问答平台，纯互联网项目，他的思想一直说这个项目是他自己这辈子真正想要做的事，自己出资金找外包团队做，不考虑融资（至少暂时），只想好好的把这样一件事做好…巴拉巴拉，这样的聊天让我感觉有点异类，真的可以做到在自己资金并不是那么充裕的前提下出资来做一件情怀的事情或产品么，这值得尊重和记忆。 他也跟我沟通，说他CTO有两三个人选，感觉我面相上像，有一种领导者的感觉，所以选我（当时听了，挺舒服的，第一次听人这样夸我…），但我们都还一直没见过面哦，他也不急，说等外包产品完成并发布后我再介入…就这样，中间等到了两个多月，在这段时间里，我在他的那个产品相关的群里逐渐发现，其实，项目除外，他并不是我想象中的那样情怀，很多可能只是言语上的高大上，或者只是我还太嫩…，当然，至少我认为，对于创业，情怀的东西需要要，但只有情怀我觉得是干不好一件事情的，就如我之前提到的，做企业你必须要考虑盈利，不以营利为目的的企业都是耍流氓。 I君、J君，… … 回到自己 创业是什么？ 我认为的创业，只是一种信息的不对称下，风口面前，事物或东西的归属，或许是你，或许是他人，区别点在于，站在风口面前的你，对这种不对称信息的了解和熟知（Ideal），你的资本是否可以经得起风口风的力度（资源／技术／团队等）？ （By aenjon 2016） 你真的需要创业么？ 你需要创业么？ 你真的需要创业么？ 这里不想谈太多其它主观客观巴拉巴拉讨论，仅一点，你想通过创业获得什么？ 财富？ 地位？ 情怀？ 梦想？ 或许是其中之一，但它们不矛盾，你冒着风险，一定抉择后艰辛旅程后这些都只是结果，仅是结果产物。 我更希望的创业是在一定的时机和阶段，做一件自己想要为之的事，把它做成，留一点东西在这个社会，让复杂的事加上你的用心变的简单，仅此而已。 知乎一句话比较直接的击中了现在很多打工人的心。 “认真读书，拿好成绩，上好大学，找好工作，去大公司。努力在公司奋斗30年，费劲力气往上爬，不乱花销，攒钱买房子，做投资。等到退休了，就是有钱人了。相信这个，并且为之付出200%的努力的，就是穷人思维”。 对比一下，前半段是我经历了经历着，似乎没得选择；后半段之前没有考虑过的，以后也不会这样考虑，不曾想过打工可以成为自己的事业，可以实现财富自由，当然，创业也未必，但有可能。为了这种可能，你觉得呢？ 我的创业路 任正非，43岁，华为，87年；马云，35岁，阿里，99年；马化腾，27岁，腾讯，98年；… 创业是一件水到渠成的事，是人人可以为之的事，所以，不着急，不忧虑，试着梳理自己的Ideal，择一其二慢慢实现，沉下心里做几件自己想做的事，相信该来的一切都会来临。而立之年，你的创业元年。 到你了你觉得呢？ 后记同步发表/转载 cnBlogs / CSDN / … By aenjon 10/2016 SZ China 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2016/10/31/aenjon/Life/而立之年，未开始的创业路/","raw":null,"content":null,"categories":[{"name":"aenjon","slug":"aenjon","permalink":"http://aenjon.com/categories/aenjon/"},{"name":"Life","slug":"aenjon/Life","permalink":"http://aenjon.com/categories/aenjon/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"http://aenjon.com/tags/Life/"},{"name":"aenjon","slug":"aenjon","permalink":"http://aenjon.com/tags/aenjon/"}]},{"title":"Jenkins Gitlab持续集成打包平台搭建","slug":"Tools/Jenkins Gitlab持续集成打包平台搭建","date":"2016-07-17T16:00:00.000Z","updated":"2016-12-08T00:26:43.000Z","comments":true,"path":"2016/07/18/Tools/Jenkins Gitlab持续集成打包平台搭建/","link":"","permalink":"http://aenjon.com/2016/07/18/Tools/Jenkins Gitlab持续集成打包平台搭建/","excerpt":"","keywords":null,"text":"相关概念Jenkins Jenkins，一个用Java编写的开源的持续集成工具，提供了软件开发的持续集成服务，可监控并触发持续重复的工作，具有开源，支持多平台和插件扩展，安装简单，界面化管理等特点。更多介绍参考维基介绍. Gitlab GitLab是一个利用Ruby on Rails开发的开源应用程序，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目，更多介绍参考维基介绍. CI 持续集成, 简称CI（continuous integration）. CI作为敏捷开发重要的一步，其目的在于让产品快速迭代的同时，尽可能保持高质量. CI一种可以增加项目可见性，降低项目失败风险的开发实践。其每一次代码更新，都要通过自动化测试来检测代码和功能的正确性，只有通过自动测试的代码才能进行后续的交付和部署. CI 是团队成员间（产研测）更好地协调工作，更好的适应敏捷迭代开发，自动完成减少人工干预，保证每个时间点上团队成员提交的代码都能成功集成的，可以很好的用于对Android/iOS项目的打包. OTA OTA（Over-the-Air Technology）空中下载技术,具体参考此文介绍. pgyer 蒲公英(pgyer)为移动开发者提供App免费测试分发应用的服务平台，支持iOS与Android，简单两步分发应用。类似的还有fir.im等. 流程结构简单绘制了下Jenkins的一个流程，如下图： IBM Developer上也有一个看似更复杂一点的图，如下图 持续交互流程图： 平台搭建Jenkins安装和启动官网： https://jenkins.io/index.html下载： http://mirrors.jenkins-ci.org/war/latest/jenkins.war 安装： 依赖于Java环境，首先安装和配置Java环境 到官网下载Jenkins,双击安装，如果是Mac电脑，会自动生成全局变量jenkins 修改参数： jenkins + 相关参数，如jenkins –httpPort=8888 #更换端口号，当默认端口8080被占用，或指定特定端口时。 启动 手动启动： java -jar jenkins.war 后台启动(默认端口)： nohup java -jar jenkins.war &amp; 后台启动(指定端口)： nohup java -jar jenkins.war -httpPort=88 &amp; 后台启动(HTTPS)： nohup java -jar jenkins.war -httpsPort=88 &amp; 浏览：http://localhost:8080/ , localhost可配置 Jenkins插件安装 插件安装 操作： Manage Jenkins -&gt; Manage Plugins -&gt; Available -&gt; Search -&gt; Click to install，如下图所示 实用插件 iOS专用：Xcode integration Android专用：Gradle plugin Gitlab插件：GitLab Plugin 和 Gitlab Hook Plugin Git插件： Git plugin GitBuckit插件： GitBuckit plugin 签名证书管理插件: Credentials Plugin 和Keychains and Provisioning Profiles Management FTP插件: Publish over FTP 脚本插件: Post-Build Script Plug-in 修改Build名称/描述(二维码)： build-name-setter / description setter plugin 获取仓库提交的commit log： Git Changelog Plugin 自定义全局变量: Environment Injector Plugin 自定义邮件插件： Email Extension Plugin 获取当前登录用户信息： build-user-vars-plugin 显示代码测试覆盖率报表： Cobertura Plugin 来展示生成的单元测试报表，支持一切单测框架，如junit、nosetests等： Junit Plugin 其它： GIT plugin / SSH Credentials Plugin Jenkins系统设置操作： Manage Jenkins -&gt; Configure System Jenkins内部shell UTF-8 编码设置，如下图所示 Jenkins Location和Email设置，如下图所示 E-mail Notification，设置如下如所示 SMTP详细配置请参考 How to send Email at every build with Jenkins Jenkins Jobs配置Jobs基础配置 配置编译参数 例如，如果需要打包者自行选择打包类型，如需要编译Release/Debug/Test等不同版本的包，那需要配置Jobs的编译参数，配置方法如下图所示： 你还可以配置一些其它参数，例如： 配置完后，build界面中就会出现，如下如所示： How to configure a single Jenkins job to make the release process from trunk or branches? 配置匿名用户权限 后面打包的应用发布时，如果懒得自己搭建服务器，就用Jenkins的，但发布出去的链接需要登录才能访问，这时候你可以设置匿名用户的访问权限，这样匿名用户可以下载访问你提供的应用链接了，非常取巧的方法，如下图： Jobs源码库配置(Gitlab为例) 配置SSH 操作： Manage Jenkins -&gt; Credentials -&gt; Global credentials (unrestricted) -&gt; Add Credentials 本机生成SSH：ssh-keygen -t rsa -C “Your email” ， 生成过程中需设置密码，最终生成id_rsa和id_rsa.pub(公钥) 本机添加秘钥到SSH：ssh-add 文件名（需输入管理密码） Gitlab上添加公钥：复制id_rsa.pub里面的公钥添加到Gitlab Jenkins上配置密钥到SSH：复制id_rsa.pub里面的公钥添加到Jenkins（private key选项） 新建Job 在Jenkins中，所有的任务都是以”Job”为单位的。在进行操作前，你需要新建一个Job，Job新建比较简单，只需要在Jenkins管理的首页左侧，点击“New Job”，一般选择free-style software project，再输入Job的名字即可。 配置Gitlab 在新建的任务（Jobs）中，Gitlab源码配置如下图：需要输入git仓库和build分支，公钥使用上面配置SSH生成的公钥。 Jobs触发条件配置Jenkins支持多种触发器配置，包括： 定期进行构建（Build periodically），定时器使用示例如下： H(25-30) 18 1-5： 工作日下午6点25到30分之间进行build H 23 1-5：工作日每晚23:00至23:59之间的某一时刻进行build H(0-29)/15 ：前半小时内每隔15分钟进行build（开始时间不确定） H/20 ：每隔20分钟进行build（开始时间不确定） 根据提交进行构建（Build when a change is pushed to GitHub） 定期检测代码更新，如有更新则进行构建（Poll SCM） Jobs构建方式/编译 配置Jenkins支持多种编译配置方式，包括： Xcode: iOS编译配置（安装Xcode integration插件） Invoke Gradle script： Android编译配置(安装Gradle plugin插件) Exceute Shell： 脚本方式 对于iOS应用的构建，如果选择Xcode方式构建，需要配置好开发者证书，具体参考后面签名和整数问题。推荐使用Exceute Shell方式，简单有效。 Jobs构建后处理 Artifacts和邮件通知配置，参考下图 可借助Email Extension Plugin 插件进行详细配置，具体可参考此文 发布 FTP服务器, 最传统的方式，可助蒲公英或者fir.im（安装对应的Jenkins插件）。 专业的Artifacts存储仓库, 比如Nexus, Artifactory等。 对象存储服务：比如阿里云OSS，AWS S3等，以阿里云为例，具体请参考此文 在Jenkins持续集成方案中使用阿里云OSS作为Artifacts仓库 当然，如果不想自己的应用发布到三方网站，只希望在自己的内网上托管，这样需要在自己内网上搭建服务器，服务器搭建方式有很多种，Mac上可以用自带的Apache服务，也可以用其它服务。 iOS的发布可能希望用到OTA，可参考此文 还有这篇一步一步实现无线安装iOS应用(内网OTA) 这里分享一个我写的shell脚本模板(已开源)，可以用于iOS的plist文件自动创建以及OTA简单发布页面的自动创建，参考此链接获取源码, 欢迎Star. 自动生成一个简单HTML界面，如下图，点击Install即可安装： 注意，这里iOS7.1以后限定必须要要用https，所以需要对jenkins设置下https，参考下面”后记” 中的Jenkins Https设置 Last Show 构建成功后最终的结果如下如所示： 后记签名和证书问题(iOS) Set up code signing for iOS projects 安装JENKINS到发布IPA中的那些坑 邮件发送失败 实际搭建过程中有遇到此问题，折腾了小会，还以为是公司邮箱地址为题，后面发现仅仅是一个小配置问题。 Extended E-mail Notification中也需要和E-mail Notification一样，点击Advanced，然后选择Use SMTP Authentication，配置同E-mail Notification的参数。 Jenkins Https Support查询Jenkins Https相关命令： 1java -jar jenkins.war --help | grep -i https 说明：下面以Mac为例. KeyStore方式 生成： 1keytool -genkey -keyalg RSA -alias selfsigned -keystore keystore.jks -storepass 密码 -dname \"cn=WEB\" 使用： 1java -jar jenkins.war --httpPort=-1 --httpsPort=8080 --httpsKeyStore=/目录/keystore.jks --httpsKeyStorePassword=密码 注意： 第一次使用时需要将”WEB”证书导入，导入步骤为：Chrome导出证书 -&gt; 安装证书 -&gt; 设置证书”全部允许”， 图解步骤可参考下面实用参考中的第5篇文章. Certificate方式 生成： 12345sudo openssl genrsa -out server.key 2048 sudo openssl req -new -key server.key -out server.csr sudo openssl genrsa -out ca.key 1024 sudo openssl req -new -x509 -days 365 -key ca.key -out ca.crt sudo openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key 使用： 启动Jenkins:1java -jar jenkins.war --httpsPort=8088 --httpsCertificate=/path/server.crt --httpsPrivateKey=/path/server.key 注意/说明：1 同上2 iOS手机需要导入cer证书(ca.crt)3 Common Name 填写IP地址或域名地址4 第5步骤如果提提示“I am unable to access the ./demoCA/newcerts directory” 错误，解决方法为：在当前操作目录，新建demoCA\\newcerts2层文件夹然后再demoCA文件夹下新建一个空的index.txt文件再新建一个serial文件，没有后缀。里面填入01 实用参考 Starting and Accessing Jenkins 官网说明 Jenkins: Switch to SSL/ HTTPS mode 支持HTTPS的两种方式 Installing and Configuring Jenkins KeyStore方式 Generating a self-signed SSL certificate using the Java keytool command (2004193) KeyStore方式 Setup Self-Signed Certificates &amp; Trusting them on OS X Certificate方式 免费openssl生成ssl证书 Certificate方式 howto-jenkins-ssl Jenkins fails to Start due to HttpsConnectorFactory openssl 生成服务端证书所遇到的问题 Refs Using Jenkins Building a software project Auto build and deploy iOS apps using Jenkins Continuous Integration for iOS with Jenkins GitLab Documentation Setup Jenkins + TestFlight for iOS apps Installing Jenkins on OS X Yosemite 基于 Jenkins 快速搭建持续集成环境 Jenkins入门 jenkins中集成OTA发布 By aenjon-2016 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2016/07/18/Tools/Jenkins Gitlab持续集成打包平台搭建/","raw":null,"content":null,"categories":[{"name":"Tech","slug":"Tech","permalink":"http://aenjon.com/categories/Tech/"},{"name":"Tools","slug":"Tech/Tools","permalink":"http://aenjon.com/categories/Tech/Tools/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://aenjon.com/tags/Android/"},{"name":"CI","slug":"CI","permalink":"http://aenjon.com/tags/CI/"},{"name":"Gitlab","slug":"Gitlab","permalink":"http://aenjon.com/tags/Gitlab/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://aenjon.com/tags/Jenkins/"},{"name":"iOS","slug":"iOS","permalink":"http://aenjon.com/tags/iOS/"}]},{"title":"Select all the cell in UITabView or UICollectionView problem","slug":"iOS/Select all the cell in UITabView or UICollectionView problem","date":"2016-06-29T16:40:20.000Z","updated":"2016-12-08T00:22:42.000Z","comments":true,"path":"2016/06/30/iOS/Select all the cell in UITabView or UICollectionView problem/","link":"","permalink":"http://aenjon.com/2016/06/30/iOS/Select all the cell in UITabView or UICollectionView problem/","excerpt":"","keywords":null,"text":"The IssueRecently in my new project I need to select all the cell data in my UITabViewCell and UICollectionViewCell, and need to do some operations with all the cells(like delete etc.), What I do as follows: UITabView 12345678910111213141516171819202122private func selectAll(select: Bool) &#123; let numSections = mListTableView?.numberOfSections if let numSections = numSections &#123; for numSection in 0 ..&lt; numSections&#123; let numItems = mListTableView?.numberOfRowsInSection(numSection) if let numItems = numItems &#123; for numItem in 0 ..&lt; numItems &#123; selectCell(NSIndexPath(forRow: numItem, inSection: numSection), select: select) &#125; &#125; &#125; &#125;&#125;private func selectCell(indexPath : NSIndexPath, select: Bool) &#123; if mListTableView?.cellForRowAtIndexPath(indexPath) != nil &#123; let cell = mListTableView?.cellForRowAtIndexPath(indexPath) as! DownloadListViewCell //cell.setSelected(select, animated: true) cell.setSelectForDelete(select) // select status UI in UITabViewCell mDownloadList[indexPath.row].selectToDelete = select // Pojo data &#125;&#125; UICollectionView 1234567891011121314151617181920212223242526private func selectAll(select: Bool) &#123; let numSections = mMyOfflineCollectView?.numberOfSections() if let numSections = numSections &#123; for numSection in 0 ..&lt; numSections&#123; let numItems = mMyOfflineCollectView?.numberOfItemsInSection(numSection) if let numItems = numItems &#123; for numItem in 0 ..&lt; numItems &#123; selectCell(NSIndexPath(forRow: numItem, inSection: numSection), flag: select) &#125; &#125; &#125; &#125;&#125;private func selectCell(indexPath : NSIndexPath, flag: Bool) &#123; if mMyOfflineCollectView.cellForItemAtIndexPath(indexPath) != nil &#123; let cell = mMyOfflineCollectView.cellForItemAtIndexPath(indexPath) as! MyOfflineCollectionViewCell cell.setSelect(flag) if flag &#123; mMyOfflineCollectView.selectItemAtIndexPath(indexPath, animated: true, scrollPosition: UICollectionViewScrollPosition.None) &#125;else &#123; mMyOfflineCollectView.deselectItemAtIndexPath(indexPath, animated: true) &#125; mMyofflinesData[indexPath.row].needDelete = flag &#125;&#125; But, The problem is , I can only select the visible cell when I scoll down or up, or do operations Solutions in NetWorkUICollectionView cellForItemAtIndexPath is nil cellForItemAtIndexPath returns nil after force scrolling to make it visible Select all the cells in UITableView Easier way to select all rows in UITableView tableView.cellForRowAtIndexPath returns nil with too many cells (swift) tableView.cellForRowAtIndexPath(indexPath) return nil The real SolutionThe real problem happened at the cellForRowAtIndexPath / cellForItemAtIndexPath, Which defined in Apple as follows: 12public func cellForRowAtIndexPath(indexPath: NSIndexPath) -&gt; UITableViewCell? // returns nil if cell is **not visible** or index path is out of range 1public func cellForItemAtIndexPath(indexPath: NSIndexPath) -&gt; UICollectionViewCell? When the cell is not visible, the cellForRowAtIndexPath will return nil,So, it’s not the right way to do the cell select operation out theUITableViewDataSource in cellForRowAtIndexPath (UITabView), you should do it separate. The right way as follows: 1234567891011121314func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCellWithIdentifier(DOWNLOAD_LIST_CELL_INDENTIFIER, forIndexPath: indexPath) as! DownloadListViewCell cell.selectionStyle = UITableViewCellSelectionStyle.None // ... cell.setSelectForDelete(self.mDownloadList[indexPath.row].selectToDelete)// select status UI in UITabViewCell // ... return cell&#125;private func selectCell(indexPath : NSIndexPath, select: Bool) &#123; mDownloadList[indexPath.row].selectToDelete = select // Pojo data mListTableView?.reloadData() // reloadData&#125; RefUITableView UICollectionView By aenjon-2016 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2016/06/30/iOS/Select all the cell in UITabView or UICollectionView problem/","raw":null,"content":null,"categories":[{"name":"Tech","slug":"Tech","permalink":"http://aenjon.com/categories/Tech/"},{"name":"iOS","slug":"Tech/iOS","permalink":"http://aenjon.com/categories/Tech/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://aenjon.com/tags/Swift/"},{"name":"iOS","slug":"iOS","permalink":"http://aenjon.com/tags/iOS/"}]},{"title":"一种提高Android应用进程存活率新方法","slug":"Android/一种提高Android应用进程存活率新方法","date":"2016-06-18T16:40:20.000Z","updated":"2016-12-08T00:24:18.000Z","comments":true,"path":"2016/06/19/Android/一种提高Android应用进程存活率新方法/","link":"","permalink":"http://aenjon.com/2016/06/19/Android/一种提高Android应用进程存活率新方法/","excerpt":"","keywords":null,"text":"基础知识Android 进程优先级1 进程优先级等级一般分法 Activte process Visible Process Service process Background process Empty process 2 Service技巧 onStartCommand返回START_STICKY onDestroy中startself Service后台变前置，setForground(true) android:persistent = “true” 3 进程优先级号 ProcessList.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Adjustment used in certain places where we don't know it yet.// (Generally this is something that is going to be cached, but we// don't know the exact value in the cached range to assign yet.)static final int UNKNOWN_ADJ = 16;// This is a process only hosting activities that are not visible,// so it can be killed without any disruption.static final int CACHED_APP_MAX_ADJ = 15;static final int CACHED_APP_MIN_ADJ = 9;// The B list of SERVICE_ADJ -- these are the old and decrepit// services that aren't as shiny and interesting as the ones in the A list.static final int SERVICE_B_ADJ = 8;// This is the process of the previous application that the user was in.// This process is kept above other things, because it is very common to// switch back to the previous app. This is important both for recent// task switch (toggling between the two top recent apps) as well as normal// UI flow such as clicking on a URI in the e-mail app to view in the browser,// and then pressing back to return to e-mail.static final int PREVIOUS_APP_ADJ = 7;// This is a process holding the home application -- we want to try// avoiding killing it, even if it would normally be in the background,// because the user interacts with it so much.static final int HOME_APP_ADJ = 6;// This is a process holding an application service -- killing it will not// have much of an impact as far as the user is concerned.static final int SERVICE_ADJ = 5;// This is a process with a heavy-weight application. It is in the// background, but we want to try to avoid killing it. Value set in// system/rootdir/init.rc on startup.static final int HEAVY_WEIGHT_APP_ADJ = 4;// This is a process currently hosting a backup operation. Killing it// is not entirely fatal but is generally a bad idea.static final int BACKUP_APP_ADJ = 3;// This is a process only hosting components that are perceptible to the// user, and we really want to avoid killing them, but they are not// immediately visible. An example is background music playback.static final int PERCEPTIBLE_APP_ADJ = 2;// This is a process only hosting activities that are visible to the// user, so we'd prefer they don't disappear.static final int VISIBLE_APP_ADJ = 1;// This is the process running the current foreground app. We'd really// rather not kill it!static final int FOREGROUND_APP_ADJ = 0;// This is a process that the system or a persistent process has bound to,// and indicated it is important.static final int PERSISTENT_SERVICE_ADJ = -11;// This is a system persistent process, such as telephony. Definitely// don't want to kill it, but doing so is not completely fatal.static final int PERSISTENT_PROC_ADJ = -12;// The system process runs at the default adjustment.static final int SYSTEM_ADJ = -16;// Special code for native processes that are not being managed by the system (so// don't have an oom adj assigned by the system).static final int NATIVE_ADJ = -17; Android Low Memory KillerAndroid系统内存不足时，系统会杀掉一部分进程以释放空间，谁生谁死的这个生死大权就是由LMK所决定的，这就是Android系统中的Low Memory Killer，其基于Linux的OOM机制,其阈值定义如下面所示的lowmemorykiller文件中，当然也可以通过系统的init.rc实现自定义。lowmemorykiller.c 123456789101112131415static uint32_t lowmem_debug_level = 1;static int lowmem_adj[6] = &#123; 0, 1, 6, 12,&#125;;static int lowmem_adj_size = 4;static int lowmem_minfree[6] = &#123; 3 * 512, /* 6MB */ 2 * 1024, /* 8MB */ 4 * 1024, /* 16MB */ 16 * 1024, /* 64MB */&#125;;static int lowmem_minfree_size = 4; ① 在Low Memory Killer中通过进程的oom_adj与占用内存的大小决定要杀死的进程，oom_adj值越小越不容易被杀死。其中，lowmem_minfree是杀进程的时机，谁被杀，则取决于lowmem_adj，具体值得含义参考上面 Android进程优先级 所述. ② 在init.rc中定义了init进程（系统进程）的oom_adj为-16，其不可能会被杀死(init的PID是1)，而前台进程是0（这里的前台进程是指用户正在使用的Activity所在的进程），用户按Home键回到桌面时的优先级是6，普通的Service的进程是8.init.rc 12# Set init and its forked children's oom_adj. write /proc/1/oom_adj -16 关于Low Memory Killer的具体实现原理可参考Ref-2. 查看某个App的进程步骤（手机与PC连接） adb shell ps | grep 进程名 cat /proc/pid/oom_adj //其中pid是上述grep得到的进程号 Linux AM命令am命令：在Android系统中通过adb shell 启动某个Activity、Service、拨打电话、启动浏览器等操作Android的命令.其源码在Am.java中，在shell环境下执行am命令实际是启动一个线程执行Am.java中的主函数（main方法），am命令后跟的参数都会当做运行时参数传递到主函数中，主要实现在Am.java的run方法中。 拨打电话命令：am start -a android.intent.action.CALL -d tel:电话号码示例：am start -a android.intent.action.CALL -d tel:10086 打开一个网页命令：am start -a android.intent.action.VIEW -d 网址示例：am start -a android.intent.action.VIEW -d http://www.aenjon.com 启动一个服务命令：am startservice &lt;服务名称&gt;示例：am startservice -n com.android.music/ com.android.music.MediaPlaybackService NotificationListenerService“A service that receives calls from the system when new notifications are posted or removed, or their ranking changed.” From Google 用来监听到通知的发送以及移除和排名位置变化,如果我们注册了这个服务，当系统任何一条通知到来或者被移除掉，我们都能通过这个service来监听到，甚至可以做一些管理工作。 Android账号和同步机制属于Android中较偏冷的知识，具体参考 Ref 3 /4 /5 Android多进程 实现：android:process 好处：一个独立的进程可以充分利用自己的RAM预算,使其主进程拥有更多的空间处理资源。此外，操作系统对待运行在不同组件中的进程是不一样的。这意味着，当系统运行在低可用内存的条件时，并不是所有的进程都会被杀死 大坑：每一个进程将有自己的Dalvik VM实例,意味着你不能通过这些实例共享数据,至少不是传统意义上的。例如,静态字段在每个进程都有自己的值,而不是你倾向于相信的只有一个值。 更多详细请参考Ref 9 现有方法网络连接保活方法A. GCMB. 公共的第三方push通道(信鸽等)C. 自身跟服务器通过轮询，或者长连接具体实现请参考 微信架构师杨干荣的”微信Android客户端后台保活经验分享” （Ref-1）. 双service(通知栏) 提高进程优先级思路：（API level &gt; 18 ） 应用启动时启动一个假的Service（FakeService）, startForeground()，传一个空的Notification 启动真正的Service（AlwaysLiveService），startForeground()，注意必须相同Notification ID FakeService stopForeground() 效果：通过adb查看,运行在后台的服务其进程号变成了1（优先级仅次于前台进程） 风险：Android系统前台service的一个漏洞，可能在6.0以上系统中修复 实现：核心代码如下 AlwaysLiveService 常驻内存服务 123456@Override public int onStartCommand(Intent intent, int flags, int startId) &#123; startForeground(R.id.notify, new Notification()); startService(new Intent(this, FakeService.class)); return super.onStartCommand(intent, flags, startId); &#125; FakeService 临时服务 1234567891011121314151617181920public class FakeService extends Service &#123; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; startForeground(R.id.notify, new Notification()); stopSelf(); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; stopForeground(true); super.onDestroy(); &#125;&#125; Service及时拉起AlarmReceiver， ConnectReceiver，BootReceiver等 Service设置（见上面基础部分） 通过监听系统广播，如开机，锁屏，亮屏等重新启动服务 通过alarm定时器，启动服务 守护进程/进程互拉在分析360手机助手app时，发现其拥有N多个进程，一个进程kill后会被其它未kill的进程拉起，这也是一种思路吧，虽然有点流氓~守护进程一般有这样两种方式： 多个java进程守护互拉 底层C守护进程拉起App上层/java进程 Linux Am命令开启后台进程一种底层实现让进程不被杀死的方法，在Android4.4以上可能有兼容性问题，具体参考Ref-7 NotificationListenerService通知一种需要用户允许特定权限的系统拉起方式，4.3以上系统 前台浮窗有朋友提出一种应用退出后启动一个不可交互的浮窗，个人觉得这种方法是无效的，读者有兴趣可以一试 新方法(AccountSync)思路利用Android系统提供的账号和同步机制实现 效果 通过adb查看,运行在后台的服务其进程号变成了1（优先级仅次于前台进程），能提高进程优先级，对比如下图 进程被系统kill后，可以由syn拉起 风险 SyncAdapter时间进度不高，往往会因为手机处于休眠状态，而时间往后调整，同步间隔最低为1分钟 用户可以单独停止或者删除，有些手机账号默认是不同步的，需要手动开启 实现 (核心代码) 1 建立数据同步系统（ContentProvider） 通过一个ContentProvider用来作数据同步，由于并没有实际数据同步，所以此处就直接建立一个空的ContentProvider即可 12345678910111213141516171819202122232425262728293031323334353637383940public class XXAccountProvider extends ContentProvider &#123; public static final String AUTHORITY = \"包名.provider\"; public static final String CONTENT_URI_BASE = \"content://\" + AUTHORITY; public static final String TABLE_NAME = \"data\"; public static final Uri CONTENT_URI = Uri.parse(CONTENT_URI_BASE + \"/\" + TABLE_NAME); @Override public boolean onCreate() &#123; return true; &#125; @Nullable @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; return null; &#125; @Nullable @Override public String getType(Uri uri) &#123; return new String(); &#125; @Nullable @Override public Uri insert(Uri uri, ContentValues values) &#123; return null; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; return 0; &#125;&#125; 然后再Manifest中声明 12345&lt;provider android:name=\"**.XXAccountProvider\" android:authorities=\"@string/account_auth_provider\" android:exported=\"false\" android:syncable=\"true\"/&gt; 2 建立Sync系统 (SyncAdapter) 通过实现SyncAdapter这个系统服务后, 利用系统的定时器对程序数据ContentProvider进行更新，具体步骤为： 创建Sync服务 123456789101112131415161718192021222324252627public class XXSyncService extends Service &#123; private static final Object sSyncAdapterLock = new Object(); private static XXSyncAdapter sSyncAdapter = null; @Override public void onCreate() &#123; synchronized (sSyncAdapterLock) &#123; if (sSyncAdapter == null) &#123; sSyncAdapter = new XXSyncAdapter(getApplicationContext(), true); &#125; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return sSyncAdapter.getSyncAdapterBinder(); &#125; static class XXSyncAdapter extends AbstractThreadedSyncAdapter &#123; public XXSyncAdapter(Context context, boolean autoInitialize) &#123; super(context, autoInitialize); &#125; @Override public void onPerformSync(Account account, Bundle extras, String authority, ContentProviderClient provider, SyncResult syncResult) &#123; getContext().getContentResolver().notifyChange(XXAccountProvider.CONTENT_URI, null, false); &#125; &#125;&#125; 声明Sync服务 123456789101112&lt;service android:name=\"**.XXSyncService\" android:exported=\"true\" android:process=\":core\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.content.SyncAdapter\"/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=\"android.content.SyncAdapter\" android:resource=\"@xml/sync_adapter\"/&gt;&lt;/service&gt; 其中sync_adapter为： 1234567&lt;sync-adapter xmlns:android=\"http://schemas.android.com/apk/res/android\" android:accountType=\"@string/account_auth_type\" android:allowParallelSyncs=\"false\" android:contentAuthority=\"@string/account_auth_provide\" android:isAlwaysSyncable=\"true\" android:supportsUploading=\"false\" android:userVisible=\"true\"/&gt; 参数说明： android:contentAuthority 指定要同步的ContentProvider在其AndroidManifest.xml文件中有个android:authorities属性。android:accountType 表示进行同步的账号的类型。android:userVisible 设置是否在“设置”中显示android:supportsUploading 设置是否必须notifyChange通知才能同步android:allowParallelSyncs 是否支持多账号同时同步android:isAlwaysSyncable 设置所有账号的isSyncable为1android:syncAdapterSettingsAction 指定一个可以设置同步的activity的Action。 账户调用Sync服务首先配置好Account（第三步），然后再通过ContentProvider实现手动更新 123456789public void triggerRefresh() &#123; Bundle b = new Bundle(); b.putBoolean(ContentResolver.SYNC_EXTRAS_MANUAL, true); b.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true); ContentResolver.requestSync( account, CONTENT_AUTHORITY, b);&#125; 添加账号 123Account account = AccountService.GetAccount(); AccountManager accountManager = (AccountManager) context.getSystemService(Context.ACCOUNT_SERVICE);accountManager.addAccountExplicitly(...) 同步周期设置 123ContentResolver.setIsSyncable(account, CONTENT_AUTHORITY, 1);ContentResolver.setSyncAutomatically(account, CONTENT_AUTHORITY, true);ContentResolver.addPeriodicSync(account, CONTENT_AUTHORITY, new Bundle(), SYNC_FREQUENCY); 3 建立账号系统 (Account Authenticator) 通过建立Account账号，并关联SyncAdapter服务实现同步 创建Account服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class XXAuthService extends Service &#123; private XXAuthenticator mAuthenticator; @Override public void onCreate() &#123; mAuthenticator = new XXAuthenticator(this); &#125; private XXAuthenticator getAuthenticator() &#123; if (mAuthenticator == null) mAuthenticator = new XXAuthenticator(this); return mAuthenticator; &#125; @Override public IBinder onBind(Intent intent) &#123; return getAuthenticator().getIBinder(); &#125; class XXAuthenticator extends AbstractAccountAuthenticator &#123; private final Context context; private AccountManager accountManager; public XXAuthenticator(Context context) &#123; super(context); this.context = context; accountManager = AccountManager.get(context); &#125; @Override public Bundle addAccount(AccountAuthenticatorResponse response, String accountType, String authTokenType, String[] requiredFeatures, Bundle options) throws NetworkErrorException &#123; // 添加账号 示例代码 final Bundle bundle = new Bundle(); final Intent intent = new Intent(context, AuthActivity.class); intent.putExtra(AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response); bundle.putParcelable(AccountManager.KEY_INTENT, intent); return bundle; &#125; @Override public Bundle getAuthToken(AccountAuthenticatorResponse response, Account account, String authTokenType, Bundle options) throws NetworkErrorException &#123; // 认证 示例代码 String authToken = accountManager.peekAuthToken(account, getString(R.string.account_token_type)); //if not, might be expired, register again if (TextUtils.isEmpty(authToken)) &#123; final String password = accountManager.getPassword(account); if (password != null) &#123; //get new token authToken = account.name + password; &#125; &#125; //without password, need to sign again final Bundle bundle = new Bundle(); if (!TextUtils.isEmpty(authToken)) &#123; bundle.putString(AccountManager.KEY_ACCOUNT_NAME, account.name); bundle.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type); bundle.putString(AccountManager.KEY_AUTHTOKEN, authToken); return bundle; &#125; //no account data at all, need to do a sign final Intent intent = new Intent(context, AuthActivity.class); intent.putExtra(AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response); intent.putExtra(AuthActivity.ARG_ACCOUNT_NAME, account.name); bundle.putParcelable(AccountManager.KEY_INTENT, intent); return bundle; &#125; @Override public String getAuthTokenLabel(String authTokenType) &#123;// throw new UnsupportedOperationException(); return null; &#125; @Override public Bundle editProperties(AccountAuthenticatorResponse response, String accountType) &#123; return null; &#125; @Override public Bundle confirmCredentials(AccountAuthenticatorResponse response, Account account, Bundle options) throws NetworkErrorException &#123; return null; &#125; @Override public Bundle updateCredentials(AccountAuthenticatorResponse response, Account account, String authTokenType, Bundle options) throws NetworkErrorException &#123; return null; &#125; @Override public Bundle hasFeatures(AccountAuthenticatorResponse response, Account account, String[] features) throws NetworkErrorException &#123; return null; &#125; &#125;&#125; 声明Account服务 123456789101112&lt;service android:name=\"**.XXAuthService\" android:exported=\"true\" android:process=\":core\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.accounts.AccountAuthenticator\"/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=\"android.accounts.AccountAuthenticator\" android:resource=\"@xml/authenticator\"/&gt;&lt;/service&gt; 其中authenticator为： 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;account-authenticator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:accountType=\"@string/account_auth_type\" android:icon=\"@drawable/icon\" android:smallIcon=\"@drawable/icon\" android:label=\"@string/app_name\"/&gt; 使用Account服务同SyncAdapter，通过AccountManager使用 申请Token主要是通过 AccountManager.getAuthToken)系列方法 添加账号则通过 AccountManager.addAccount) 查看是否存在账号通过 AccountManager.getAccountsByType) Refs 微信Android客户端后台保活经验分享 Android Low Memory Killer原理 stackOverflow 上介绍的双Service方法 Write your own Android Sync Adapter Write your own Android Authenticator Android developer android.accounts AccountManager AbstractAccountAuthenticator AccountAuthenticatorActivity Creating a Sync Adapter Android篇从底层实现让进程不被杀死（失效Closed） Android 4.3+ NotificationListenerService 的使用 Going multiprocess on Android 后记 2016.5.24 1. 本文发布时间写错了，5.19手贱成了6.19，就酱紫吧，懒得改了，五月份看过的童鞋就当狠狠滴穿越了一把吧，O(∩_∩)O哈哈哈~~ 2. 本文在V2EX、稀土掘金、博客园、CSDN等等诸多网站上有转载或发布，收到了很多评论和讨论，其中有一部分以“天下兴亡匹夫有责”的心态批判笔者等同类开发者把Android生态给搞坏了，提到iOS的诸多好处等等，阐述几点个人观点： ① 据笔者研究，目前双Service拉起的方式在国内排前几的应用(微信/支付宝等等)中都有用到，进程互拉方式在360手机助手、应用宝等应用中有用到，这些才是真正黑科技，笔者提到的方法仅仅是取巧性的用到了Android系统提供的方法，谈不上XXX~~ ② iOS的封闭造就其天然的优势,不存在这些问题; 而Android的开源，有诸多问题但不可否认的是其促进了技术的发展，科技的发展甚至人类的进步。 物极必反，很多事情都是双刃剑~ ③ 后来经一些网友提醒，发现所谓提异议的这群家伙都是产品汪，半吊子技术，所以XXOO~~ ④ 法海无涯,技术无边,风涯无罪,南无阿弥陀佛~~ By aenjon-2016 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2016/06/19/Android/一种提高Android应用进程存活率新方法/","raw":null,"content":null,"categories":[{"name":"Tech","slug":"Tech","permalink":"http://aenjon.com/categories/Tech/"},{"name":"Android","slug":"Tech/Android","permalink":"http://aenjon.com/categories/Tech/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://aenjon.com/tags/Android/"},{"name":"存活率","slug":"存活率","permalink":"http://aenjon.com/tags/存活率/"},{"name":"进程","slug":"进程","permalink":"http://aenjon.com/tags/进程/"}]},{"title":"一道Android OpenGL笔试题","slug":"AR_VR/一道Android OpenGL笔试题","date":"2016-05-05T01:40:20.000Z","updated":"2016-12-08T00:25:47.000Z","comments":true,"path":"2016/05/05/AR_VR/一道Android OpenGL笔试题/","link":"","permalink":"http://aenjon.com/2016/05/05/AR_VR/一道Android OpenGL笔试题/","excerpt":"","keywords":null,"text":"题目 设计一个Android平台的Gallery组件，要求Gallery中每个item内的图片显示达成有效显示的最大精度，并保证Gallery在滚屏时能够全60FPS帧率地及时显示出加载的图片。请详细说明实现架构、关键技术点及APIs。 约束条件：GPU空间传输通道带宽较小，对于400*400pixel尺寸的图像而言，一次传输耗时超过30ms。 答案当时的答案如下： 1. Gallery组件类图 Gallery组件类图设计如下图所示，其中: GalleryView为自定义Gallery组件视图; GalleryRenderer为GLSurfaceView的Renderer. AbstractImage为抽象的ImageView基类，子类继承实现loadGLTexture和Draw DataCache为图片缓存类，NetworkHelper为NetWork模块的管理类，负责图片的下载. 2. 关键技术点及相关API设计 2.1 最大精度下60fps帧率显示图片 方案1： VBO/FBO方案VBO(Vertex Buffer Array)： OpenGL存储顶点数据的高速缓存，可减少渲染时间，相关APIs如下(OpenGL ES 2.0以上) 1234GLES20.glGenBuffers(1, vboId, 0);//申请GLES20.glBindBuffer(GLES30.GL_ARRAY_BUFFER, vboId[0]);//绑定GLES20.glBufferData(GLES30.GL_ARRAY_BUFFER, vertexBuffer.capacity() * 4,vertexBuffer,GLES30.GL_STATIC_DRAW);//存储 GLES20.glBindBuffer(GLES30.GL_ARRAY_BUFFER, 0); 参考 PBO(Pixel Buffer Object)：OpenGL存储像素数据的高速缓存，可实现快速的像素数据传递，减少数据的拷贝/传递时间，相关APIs如下(OpenGL ES 3.0以上) 1234567GLES30.glReadBuffer(GLES30.GL_BACK); //set framebuffer to read fromGLES30.glBindBuffer(GLES30.GL_PIXEL_PACK_BUFFER, mPboHandleContainer[0]); // bind pboGLES30.glReadPixels(0, 0, width, height, GLES30.GL_RGBA, GLES30.GL_UNSIGNED_BYTE, pboByteBuffer); // read pixelsByteBuffer byteBuffer =((ByteBuffer) GLES30.glMapBufferRange(GLES30.GL_PIXEL_PACK_BUFFER, 0, 4 * mWidth * mHeight, GLES30.GL_MAP_READ_BIT)).order(ByteOrder.nativeOrder()); // map pbo to bbGLES30.glUnmapBuffer(GLES30.GL_PIXEL_PACK_BUFFER);// unmap pboGLES30.glBindBuffer(GLES30.GL_PIXEL_PACK_BUFFER, 0);// unbind pbo PBO DMA异步快速传递原理及多缓存对象设计 如下面两图所示，其中上图是传统的方法从图像源载入图像数据到纹理对象的过程，像素数据首先存到系统内存中，接着使用glTexImage2D将数据从系统内存拷贝到纹理对象，包含的两个子过程均需要有CPU执行；而下图中，像素数据是直接载入到PBO中，这个过程仍需要CPU来执行，但是从数据从PBO到纹理对象的过程则由GPU来执行DMA，不需要CPU参与。而且opengl可安排异步DMA，不必马上进行像素数据的传递。因此，相比而言，下图中的glTexImage2D立即返回而不是马上执行，这样CPU可以执行其它的操作而不需要等待像素数据传递的结束。 如下图所示表示同时使用了两个PBO。在glTexSubImage2D将像素数据从PBO拷贝出来的同时，另一份像素数据写进了另一个PBO。即在第n帧时，PBO1用于glTexSubImage2D，而PBO2用于生成一个新的纹理对象了。再到n+1帧时，两个PBO则互换了角色。由于异步DMA传递，像素数据的更新和拷贝过程可同时进行，即CPU将纹理源更新到PBO，同时GPU将从另一PBO中拷贝出纹理，从而提高处理速度。 参考（图片来源） 方案二：Triple-Buffering等 Triple-Buffering基本思路：frame N正在显示时，frameN+1已经缓存并准备好(Only ready to show)，frameN+2已经开始获取 纹理索引基本思路：所有图片都对应一个索引值，cache on memory，preloading，滑动时快速切换索引 2.2 Gallery组件架构 Gallery组件是一个独立的模块，前期设计时需考虑后期的可维护性性及可可扩展性等进行综合考虑，例如Gallery中图片的来源，可能来自本地或者网络下载，这样设计时需要将图片加载的模块单独抽离出来以便可扩展性等; 同时，从框架上考虑，Android组件的设计在具体情况下可考虑MVC/MVP等模式，这样不仅便于后期可维护可扩展，另外也能很好的将Model、View和Control/Presenter分离. 思考/讨论 由于该题是OpenGL题目，所以笔者在回答时重点侧重在图片的显示上，而对图片的加载直接忽略掉了，后面想一下，还是在上述答案中加上对Android中图片下载的多级缓存设计会比较好。 OpenGL渲染深入 大家有好的答案或建议可直接下面留言回复，一起讨论! ~ By aenjon-2016 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2016/05/05/AR_VR/一道Android OpenGL笔试题/","raw":null,"content":null,"categories":[{"name":"Tech","slug":"Tech","permalink":"http://aenjon.com/categories/Tech/"},{"name":"OpenGL","slug":"Tech/OpenGL","permalink":"http://aenjon.com/categories/Tech/OpenGL/"}],"tags":[{"name":"AR/VR","slug":"AR-VR","permalink":"http://aenjon.com/tags/AR-VR/"},{"name":"Android","slug":"Android","permalink":"http://aenjon.com/tags/Android/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://aenjon.com/tags/OpenGL/"}]},{"title":"aenjon-Reading Sharing-Life","slug":"aenjon/aenjon-Reading_Sharing-Life","date":"2016-01-10T17:23:20.000Z","updated":"2016-12-08T00:27:21.000Z","comments":true,"path":"2016/01/11/aenjon/aenjon-Reading_Sharing-Life/","link":"","permalink":"http://aenjon.com/2016/01/11/aenjon/aenjon-Reading_Sharing-Life/","excerpt":"","keywords":null,"text":"2016 【讀書筆記】成为技术领导者 2016 before 【讀書筆記】精益创业实战 【讀書筆記】高效能人士的七个习惯 【讀書筆記】人人都是产品经理 【分享】RSS订阅技巧及工具和实用RSS链接分享 By aenjon 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2016/01/11/aenjon/aenjon-Reading_Sharing-Life/","raw":null,"content":null,"categories":[{"name":"aenjon","slug":"aenjon","permalink":"http://aenjon.com/categories/aenjon/"},{"name":"Reading","slug":"aenjon/Reading","permalink":"http://aenjon.com/categories/aenjon/Reading/"}],"tags":[{"name":"Life","slug":"Life","permalink":"http://aenjon.com/tags/Life/"},{"name":"Reading","slug":"Reading","permalink":"http://aenjon.com/tags/Reading/"},{"name":"aenjon","slug":"aenjon","permalink":"http://aenjon.com/tags/aenjon/"}]},{"title":"完整开源项目荟萃（iOS篇）","slug":"iOS/完整开源项目荟萃（iOS篇）","date":"2015-11-29T17:01:00.000Z","updated":"2016-12-11T09:00:24.000Z","comments":true,"path":"2015/11/30/iOS/完整开源项目荟萃（iOS篇）/","link":"","permalink":"http://aenjon.com/2015/11/30/iOS/完整开源项目荟萃（iOS篇）/","excerpt":"","keywords":null,"text":"IntroductionAbout “【All-OpenSource-Project】” 致力于收集完整优质/优秀/优美完整的Android/iOS/Web等开源项目 欢迎您的加入! Fork or Email to Me, tks! Contributeaenjon … History 2015.11.30 First Create Categories 新闻/资讯 ioctocat GitHub iOS客户端iOctocat v1 - GitHub for iOS (works on the iPhone, iPad, and iPod Touch) http://ioctocat.com/ iphone-app 开源中国社区 iPhone 客户端 GameDaily 电竞第一视角iOS Game Video App compatible with iPhone and iPad. 社交/聊天 读书/图片/音乐/视频 DoubanAlbum 豆瓣相册 Slowslab iOS应用 豆瓣相册 精选集 开源项目，http://www.douban.com/people/slowslab/ Reader iOS PDF阅读器PDF Reader Core for iOS http://www.vfr.org/ 学习/工具 NewsReader VOA在线英语 iOS News Reader compatible with iPhone and iPad，详细介绍 游戏 高仿系列 meituan 高仿美团高仿美团iOS版，版本号5.7 nuomi 高仿百度糯米高仿百度糯米iOS版，版本号5.13.0 其它 MGBoxKit iOS 优雅组件Simple, quick iOS tables, grids, and more By aenjon 11/30/2015 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2015/11/30/iOS/完整开源项目荟萃（iOS篇）/","raw":null,"content":null,"categories":[{"name":"Tech","slug":"Tech","permalink":"http://aenjon.com/categories/Tech/"},{"name":"iOS","slug":"Tech/iOS","permalink":"http://aenjon.com/categories/Tech/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://aenjon.com/tags/iOS/"}]},{"title":"完整开源项目荟萃（Android篇）","slug":"Android/完整开源项目荟萃（Android篇）","date":"2015-11-29T17:00:00.000Z","updated":"2016-12-09T07:16:03.000Z","comments":true,"path":"2015/11/30/Android/完整开源项目荟萃（Android篇）/","link":"","permalink":"http://aenjon.com/2015/11/30/Android/完整开源项目荟萃（Android篇）/","excerpt":"","keywords":null,"text":"IntroductionAbout “【All-OpenSource-Project】” 致力于收集完整优质/优秀/优美完整的Android/iOS/Web等开源项目 欢迎您的加入! Fork or Email to Me, tks! Contributeaenjon … History 2015.11.30 First Create Categories 新闻/资讯 Github GitHub 客户端An elegent Android Client for Github. 不仅仅是Github客户端，而且是一个发现优秀Github开源项目的app GithubTrends GitHub TrendingGitHub Trending repositories Viewer with Material Design TopNews 头条新闻高仿“今日头条”客户端，实现它的大部分功能 36krReader 36氪客户端MD风格的36氪Android阅读客户端 cnblogs 博客园客户端博客园客户端（作者有保留，未完全开源） FanfouDaily 饭否精选 Meizhi 干妹子每天自动更新一张精选妹纸图、一个小视频、一系列精选程序猿干货（周末不更新） GanHuoIO基于Gank.IO提供的API的第三方客户端（RxJava+Retrofit+MVP） ZhiHuDaily-React-Native 知乎日报 ZhihuDailyPurify 更纯净的知乎日报 ZhuanLan 知乎专栏 LookLook 新闻阅读，知乎日报等 android-arsenal.com android-arsenal.com客户端 社交/聊天 MyDiary 君の名は。, 你的名字 读书/图片/音乐/视频 SimplifyReader一款基于Google Material Design设计开发的Android客户端，包括新闻简读，图片浏览，视频爽看 ，音乐轻听以及二维码扫描五个子模块 shuba 书吧专注为用户提供人性化的搜书引擎，快捷，方便，为用户找到最好的小说 JamsMusicPlayer 强大的音乐播放器A free, powerful and elegant music player for Android. Material-Movies MD风格视频播放器An application about movies with material design 工具/学习todo系列 Minimal-TodoA fully Material ToDo app with minimal features, just enough to be useful. Todo-AndroidTodo Android App using Realm and Lolipop Material Design. TodayThing一款简单的 Material Design 风格的 to do list 应用 Android辅助工具 AmazeFileManager Amaze File Manager MobileSafer 手机安全小卫士 MemoryMonitor一款开发者专用的内存清理、Pss监控工具 游戏 高仿系列 wechat 微信 bilibili-android-client 高仿哔哩哔哩动画安卓客户端An unofficial bilibili client for android http://www.jianshu.com/p/f69a55b94c05 Android组件篇 DanmakuFlameMaster 弹幕引擎Android开源弹幕引擎·烈焰弹幕使 ～ http://app.bilibili.com/ 其它By aenjon 11/30/2015 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2015/11/30/Android/完整开源项目荟萃（Android篇）/","raw":null,"content":null,"categories":[{"name":"Tech","slug":"Tech","permalink":"http://aenjon.com/categories/Tech/"},{"name":"Android","slug":"Tech/Android","permalink":"http://aenjon.com/categories/Tech/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://aenjon.com/tags/Android/"}]},{"title":"手掌手指分割算法（源码）","slug":"CV/手掌手指分割算法","date":"2014-07-24T15:40:20.000Z","updated":"2016-12-08T00:28:50.000Z","comments":true,"path":"2014/07/24/CV/手掌手指分割算法/","link":"","permalink":"http://aenjon.com/2014/07/24/CV/手掌手指分割算法/","excerpt":"","keywords":null,"text":"开发环境开发环境 64 bits Windows OS (Win8.1) VS2013 OpenCV 2.4.9 功能原理 算法要求 完成将Camera拍摄的手掌图片中分割出每个手指用于指纹识别 算法流程 核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#ifdef TIME_RUN_COST double duration = static_cast&lt;double&gt;(cv::getTickCount());//time#endif cout &lt;&lt; \"filename=\" &lt;&lt; filename &lt;&lt;endl; Mat src = imread(filename, CV_LOAD_IMAGE_COLOR); if (src.empty()) &#123; cout &lt;&lt; \"imread error!!!\"; getchar(); return -1; &#125;#ifdef BOB_DBG_COM memset(out_filename, 0, sizeof(out_filename) / sizeof(char)); sprintf(out_filename, \"%s-%s.jpg\",out_name,\"0-0src\"); imwrite(out_filename, src);#endif // BOB_DBG_COM #if 0 int scaleSize = 4; resize(src, src, Size(src.cols / scaleSize, src.rows / scaleSize), 0, 0, CV_INTER_AREA); memset(out_filename, 0, sizeof(out_filename) / sizeof(char)); sprintf(out_filename, \"%s-%s.jpg\", out_name, \"0-0src\"); imwrite(out_filename, src);#endif#if 1 cout &lt;&lt; \"cut...\" &lt;&lt; endl; int width = src.cols; int height = src.rows; float scale = 0.8; cout &lt;&lt; \"width=\" &lt;&lt; width &lt;&lt; \",height=\" &lt;&lt; height &lt;&lt; endl; Rect rect(0, 0, width, height*scale); Mat imgCut; imgCut = src(rect).clone(); #endif //Mat imgCut = src; cout &lt;&lt; \"filter...\" &lt;&lt; endl; // filter2D(imgCut, imgCut, -1, kernel); GaussianBlur(imgCut, imgCut, Size(5, 5), 0, 0); // blur(imgCut, imgCut, Size(5, 5)); #if 0 cout &lt;&lt; \"EqualizeHist...\" &lt;&lt; endl; Mat matOutEqualizeHist = Mat(imgCut.size(), CV_8UC3); //IplImage* pImgOutEqualizeHist = cvCreateImage(cvSize(cameraFrame.cols, cameraFrame.rows), IPL_DEPTH_8U, 3); IplImage pImgInEqualizeHist = (IplImage)(imgCut); // Mat-&gt; IplImage IplImage* pImgOutEqualizeHist = EqualizeHistColorImage(&amp;pImgInEqualizeHist); matOutEqualizeHist = pImgOutEqualizeHist; //IplImage -&gt; Mat#endif // out Mat imgSrc = Mat(imgCut.size(), CV_8UC1); imgCut.copyTo(imgSrc); Mat imgContour = Mat(imgSrc.size(), CV_8UC1);#ifdef FINGER_EXTRACT_AT_NIGHT cout &lt;&lt; \"Nigth,Threshold...\" &lt;&lt; endl; Mat imgTmp;// = Mat(imgCut.size(), CV_8UC1); cvtColor(imgSrc, imgTmp, CV_RGB2GRAY); cvThresholdOtsu(&amp;((IplImage)imgTmp), &amp;((IplImage)imgTmp)); imgTmp.copyTo(imgContour);#else cout &lt;&lt; \"Day,Skin...\" &lt;&lt; endl; Mat imgSkin2 = Mat(imgSrc.size(), CV_8UC1); IplImage* pImgSkin2 = cvCreateImage(cvSize(imgSrc.cols, imgSrc.rows), IPL_DEPTH_8U, 1); IplImage pImg2 = (IplImage)(imgSrc); // Mat-&gt; IplImage cvSkinOtsu(&amp;pImg2, pImgSkin2); imgSkin2 = pImgSkin2; //IplImage -&gt; Mat //Mat imgSkin = Mat(imgSrc.size(), CV_8UC1); imgSkin2.copyTo(imgContour);#endif /////////////////////// Contours cout &lt;&lt; \"Find Contours...\" &lt;&lt; endl; vector&lt;vector&lt;cv::Point&gt; &gt; contours; vector&lt;Vec4i&gt; hierarchy; findContours(imgContour, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0)); sort(contours.begin(), contours.end(), compareContourAreas); int contours_num = contours.size(); cout &lt;&lt; \"contours_num=\" &lt;&lt; contours_num &lt;&lt; endl;#if 0 vector&lt;vector&lt;Point&gt;&gt;::const_iterator itContours = contours.begin(); //for (int i = 0; i &lt; contours.size(); i++) for (; itContours != contours.end(); ++itContours) &#123; cout &lt;&lt; \"Size: \" &lt;&lt; itContours-&gt;size() &lt;&lt; endl;//每个轮廓包含的点数 &#125;#endif#if 1 //usd // Eliminate too short or too long contours int cmin = 100; // minimum contour length //int cmax= 1000; // maximum contour length vector&lt;vector&lt;Point&gt;&gt;::const_iterator itc = contours.begin(); while (itc != contours.end()) &#123; //if (itc-&gt;size() &lt; cmin || itc-&gt;size() &gt; cmax) if (itc-&gt;size() &lt; cmin) &#123; itc = contours.erase(itc); &#125; else ++itc; &#125; contours_num = contours.size(); cout &lt;&lt; endl &lt;&lt; \"contours_num after Eliminate=\" &lt;&lt; contours_num &lt;&lt; endl;#endif // extract the contour img cout &lt;&lt; \"Extract Contours...\" &lt;&lt; endl; if (contours_num &gt;= 4) &#123; Mat img1, img2, img3, img4; std::vector&lt;cv::Point&gt; biggest1Contour = contours[contours_num - 1]; std::vector&lt;cv::Point&gt; biggest2Contour = contours[contours_num - 2]; std::vector&lt;cv::Point&gt; biggest3Contour = contours[contours_num - 3]; std::vector&lt;cv::Point&gt; biggest4Contour = contours[contours_num - 4]; std::vector&lt;cv::Point&gt; smallestContour = contours[0]; extractFingerImg2(contours, imgSrc, img1, contours_num, 1); extractFingerImg2(contours, imgSrc, img2, contours_num, 2); extractFingerImg2(contours, imgSrc, img3, contours_num, 3); extractFingerImg2(contours, imgSrc, img4, contours_num, 4); &#125; else if (contours_num == 3) &#123; Mat img1, img2, img3; std::vector&lt;cv::Point&gt; biggest1Contour = contours[contours_num - 1]; std::vector&lt;cv::Point&gt; biggest2Contour = contours[contours_num - 2]; std::vector&lt;cv::Point&gt; biggest3Contour = contours[contours_num - 3]; std::vector&lt;cv::Point&gt; smallestContour = contours[0]; extractFingerImg2(contours, imgSrc, img1, contours_num, 1); extractFingerImg2(contours, imgSrc, img2, contours_num, 2); extractFingerImg2(contours, imgSrc, img3, contours_num, 3); &#125; else if (contours_num == 2) &#123; Mat img1, img2; std::vector&lt;cv::Point&gt; biggest1Contour = contours[contours_num - 1]; std::vector&lt;cv::Point&gt; biggest2Contour = contours[contours_num - 2]; std::vector&lt;cv::Point&gt; smallestContour = contours[0]; extractFingerImg2(contours, imgSrc, img1, contours_num, 1); extractFingerImg2(contours, imgSrc, img2, contours_num, 2); &#125; else if (contours_num == 1) &#123; Mat img1; std::vector&lt;cv::Point&gt; biggest1Contour = contours[contours_num - 1]; std::vector&lt;cv::Point&gt; smallestContour = contours[0]; extractFingerImg2(contours, imgSrc, img1, contours_num, 1); &#125; else &#123; cout &lt;&lt; \"error\" &lt;&lt; endl; &#125;#ifdef TIME_RUN_COST duration = static_cast&lt;double&gt;(cv::getTickCount()) - duration; duration /= cv::getTickFrequency(); // the elapsed time in ms cout &lt;&lt; \"time cost=\" &lt;&lt; duration &lt;&lt; \"s\"&lt;&lt;endl;#endif#ifdef BOB_DBG_COM memset(out_filename, 0, sizeof(out_filename) / sizeof(char)); sprintf(out_filename, \"%s-%s.jpg\", out_name, \"4-imgContoursInSrc\"); imwrite(out_filename, imgSrc); //imwrite(\"4-imgContoursInSrc.jpg\", imgSrc);#endif // BOB_DBG_COM 算法效果 白天复杂场景 晚上场景 批量测试场景 By aenjon-2014合作联系：aenjon00@163.com————————版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2014/07/24/CV/手掌手指分割算法/","raw":null,"content":null,"categories":[{"name":"Tech","slug":"Tech","permalink":"http://aenjon.com/categories/Tech/"},{"name":"CV","slug":"Tech/CV","permalink":"http://aenjon.com/categories/Tech/CV/"}],"tags":[{"name":"CV/MV","slug":"CV-MV","permalink":"http://aenjon.com/tags/CV-MV/"},{"name":"DIP","slug":"DIP","permalink":"http://aenjon.com/tags/DIP/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://aenjon.com/tags/OpenCV/"},{"name":"Project","slug":"Project","permalink":"http://aenjon.com/tags/Project/"},{"name":"图像算法","slug":"图像算法","permalink":"http://aenjon.com/tags/图像算法/"}]},{"title":"《Android NFC 开发实战详解 》","slug":"NFC/《Android NFC 开发实战详解 》","date":"2014-03-14T15:23:23.000Z","updated":"2016-12-08T00:26:25.000Z","comments":true,"path":"2014/03/14/NFC/《Android NFC 开发实战详解 》/","link":"","permalink":"http://aenjon.com/2014/03/14/NFC/《Android NFC 开发实战详解 》/","excerpt":"","keywords":null,"text":"啰嗦 哇哈..,历时一年多，一哥的第一本书终于要出版了 (原本应该今年年初出版的,跟马航一样, 莫名其妙就拖到了现在 , 据出版社最新消息, 预计三月中下旬正式出版,敬请期待), 封面如下, 感谢人民邮电的张涛老师为本书的付出,……这本书的写作大概是从去年的3月左右开始的, 全书分为三大块,分别为基础篇,应用篇和实例篇(具体见下述MENU)… About LINK 出版社 china-pub Amazon 京东 当当 NFC相关 QQ群NFC产品联盟 221281036 MENU第一篇 基础篇 第1章 NFC概述 1.1 RFID基础… 2 1.1.1 RFID简介…. 2 1.1.2 RFID系统的组成和工作原理…. 3 1.1.3 RFID应用概述…. 6 1.2 NFC基础… 7 1.2.1 NFC简介…. 7 1.2.2 技术比较…. 8 1.2.3 NFC设备…. 11 1.2.4 NFC通讯模式…. 11 1.2.5 NFC工作模式和应用分类…. 13 1.3 NFC工作原理… 15 1.4 NFC应用实例… 16 1.4.1 NFC生态系统…. 16 1.4.2 NFC应用实例…. 17 1.5 NFC开发常用网络资源… 19 1.6 本章小结… 20 第2章 NFC协议基础 2.1 NFC技术标准… 21 2.2 NFC标准规范… 24 2.2.1 ISO 14443. 24 2.2.2 NFCIP-1. 25 2.2.3 MIFARE. 26 2.2.4 FeliCa. 26 2.3 NFC TAG.. 27 2.3.1 NFC Forum定义的Tag类型…. 27 2.3.2 NXP特定的Tag类型…. 29 2.4 NDEF协议… 29 2.4.1 NDEF概述…. 30 2.4.2 NDEF实例…. 33 2.5 RTD协议… 34 2.5.1 RTD_TEXT.. 34 2.5.2 RTD_URI 35 2.5.3 RTD_Smart Poster 36 2.6 LLCP协议… 37 2.7 NFC协议汇总… 39 2.8 本章小结… 40 第3章 NFC开发中的Android基础… 41 3.1 Android概述… 41 3.1.1 Android基础概念…. 41 3.1.2 Android开发工作…. 42 3.1.3 Android开发环境…. 42 3.2 Android应用程序结构… 44 3.3 Android系统架构… 45 3.4 NFC开发中必备的Android知识… 47 3.4.1 Activity生命周期…. 47 3.4.2 Intent-Filter 48 3.5 Android TV中的NFC开发… 50 3.5.1 Android TV+集成NFC硬件…. 50 3.5.2 Android TV+集成NFC Tag. 51 3.5.3 Android TV+集成NFC的RC.. 52 3.5.4 Android TV +集成NFC的RC+集成NFC硬件…. 53 3.6 本章小结… 54 第二篇 应用/技术篇 第4章 Android NFC API概述… 56 4.1 Android中的NFC API 56 4.1.1 android.nfc包…. 56 4.1.2 android.nfc.tech包…. 59 4.1.3 NFC API使用第一步：NFC在Android Manifest中的设置…. 59 4.1.4 NFC API使用第二步：NfcAdapter的获取…. 60 4.2 NFC标签调度系统… 62 4.2.1 NFC前台调度系统…. 62 4.2.2 NFC标签调度系统…. 63 4.2.3 NFC标签映射…. 64 4.2.4 应用程序如何调度NFC标签…. 65 4.3 NFC Intent过滤器… 66 4.3.1 ACTION_NDEF_DISCOVERED.. 66 4.3.2 ACTION_TECH_DISCOVERED.. 70 4.3.3 ACTION_TAG_DISCOVERED.. 71 4.4 Android应用程序记录… 72 4.4.1 AAR基础…. 72 4.4.2 AAR和Intent 过滤器的区别…. 72 4.4.3 Android中AAR的使用…. 73 4.5 Android NFC API与系统版本对应表… 73 4.6 本章小结… 74 第5章 NFC读写模式开发… 79 5.1 关于NFC读写模式… 79 5.2 TAG读操作（NDEF数据）… 79 5.2.1 TAG读操作步骤…. 80 5.2.2 TAG读操作实例…. 86 5.3 TAG写操作（NDEF数据）… 98 5.3.1 TAG写操作步骤…. 98 5.3.2 TAG写操作实例…. 108 5.4 基于AAR的TAG读写操作… 121 5.5 非NDEF数据TAG读操作… 121 5.6 本章小结… 123 第6章 NFC P2P模式开发… 124 6.1 关于NFC P2P模式… 124 6.1.1 Beam使用的条件…. 124 6.1.2 Beam Enable的判断…. 125 6.2 Android NFC P2P开发基础… 126 6.2.1 Android Beam实现的几种方式…. 127 6.2.2 Beam NDEF消息（BNM）…. 129 6.2.3 接收Beam消息（RBM）…. 130 6.2.4 enableForegroundNdefPush的使用…. 130 6.3 Android NFC P2P开发实例… 132 6.3.1 实例1：使用setNdefPushMessageCallback实现Android Beam.. 132 6.3.2 实例2：使用setNdefPushMessage实现Android Beam.. 143 6.3.3 实例3：使用enableForegroundNdefPush实现Android Beam.. 151 6.3.4 实例4：结合AAR实现Android Beam.. 157 6.4 Android NFC P2P开发进阶… 162 6.4.1 Beam实现文件传输的方法…. 162 6.4.2 Beam文件传输实例1：setBeamPushUris. 164 6.4.3 Beam文件传输实例2：setBeamPushUrisCallback. 169 6.5 本章小节… 172 第7章 NFC卡模拟模式开发… 173 7.1 关于NFC卡模拟模式… 173 7.2 基于硬件的卡模拟—虚拟卡模式… 174 7.2.1 虚拟卡模式概述…. 174 7.2.2 安全单元SE和SWP. 174 7.2.3 虚拟卡模式的开发…. 177 7.3 基于软件的卡模拟—主机卡模式… 183 7.3.1 主机卡模式概述…. 183 7.3.2 主机卡模式的优点…. 184 7.3.3 主机卡模式的隐患…. 185 7.3.4 主机卡模式的开发…. 187 7.4 卡模拟模式前景… 187 7.5 本章小结… 188 第三篇 实例篇 第8章 NFC实例一——WiFi快速连接助手… 190 8.1 开发背景及功能概述… 190 8.1.1 开发背景…. 190 8.1.2 功能概述…. 190 8.1.3 开发环境和目标平台…. 191 8.2 软件预览及功能结构… 191 8.2.1 软件预览…. 191 8.2.2 功能结构…. 194 8.3 主界面设计… 195 8.3.1 WiFi信息配置界面…. 195 8.3.2 WiFi配置信息TAG写入界面…. 197 8.3.3 AndroidManifest. Xml文件…. 198 8.4 主程序实现… 199 8.4.1 WiFi配置信息输入模块…. 199 8.4.2 WiFi配置信息TAG写入模块…. 203 8.4.3 TAG WiFi信息读取模块…. 207 8.4.4 WiFi自动连接模块…. 211 8.4.5 UI辅助模块…. 214 8.5 本章小结… 215 第9章 NFC实例二——EasyTagWrite.. 216 9.1 开发背景及功能概述… 216 9.1.1 开发背景…. 216 9.1.2 功能概述…. 216 9.1.3 开发环境和目标平台…. 217 9.2 软件预览及功能结构… 217 9.2.1 软件预览…. 217 9.2.2 功能结构…. 220 9.3 主界面设计… 220 9.4 主程序实现… 223 9.4.1 UI交互模块…. 223 9.4.2 NDEF消息生成模块…. 228 9.4.3 NDEF消息写入模块…. 231 9.5 本章小结… 231 第10章 NFC实例三——NFCard.. 232 10.1 NFCard概述… 232 10.1.1 简介…. 232 10.1.2 环境平台…. 232 10.2 软件预览及功能结构… 233 10.2.1 软件预览…. 233 10.2.2 功能结构…. 234 10.3 主界面解析… 235 10.4 主程序解析… 238 10.4.1 UI交互模块…. 239 10.4.2 Card读取模块…. 244 10.4.3 Card解析模块…. 247 10.5 本章小结… 249 附录 缩略语和约定语 250 CODE &amp; 样章*书中实例源码 *封面及目录 *第四章 勘误和支持由于作者水平有限，加之写作时间仓促，书中难免会出现一些错误或不准确的地方，恳请读者批评和指正。若有问题，可通过邮箱与笔者共同讨论，笔者联系方式为：aenjon00@163.com 勘误ING P96页，5.2.2下面的”(1)主程序P2PDemo1.java….”， 改为 “(1)主程序ReadTag_RTDUrl.java…” P118页，5.3.2下面的”主程序P2PDemo1.java…” 改为“主程序WriteTag_RTDUrl.java…” P251页，在NDEF消息获取模块代码中，第4~45行之间漏掉了判断，在第4行前加上（GitHub已更新） P121页类似，为了演示将三个判断都加进去了，其中有两个(是具体TAG类型而定，NDEF和TAG)需要加return的. P73,P89,P108页 中的 ACTION_TAB_DISCOVERED，改为ACTION_TAG_DISCOVERED P68页，ACTION_NFC_SETTINGS…使用该方法，需要在Android API 9+以上系统中…（改为API 16+） P36页，表2-6中 Payload_lenght改为Payload_length （收集中…） By aenjon-2014aenjon cnBlogsaenjon CSDN 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2014/03/14/NFC/《Android NFC 开发实战详解 》/","raw":null,"content":null,"categories":[{"name":"Tech","slug":"Tech","permalink":"http://aenjon.com/categories/Tech/"},{"name":"NFC","slug":"Tech/NFC","permalink":"http://aenjon.com/categories/Tech/NFC/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://aenjon.com/tags/Android/"},{"name":"NFC","slug":"NFC","permalink":"http://aenjon.com/tags/NFC/"}]},{"title":"写在年末, 我的2013","slug":"aenjon/Life/写在年末, 我的2013","date":"2013-11-30T15:23:23.000Z","updated":"2016-12-08T00:27:39.000Z","comments":true,"path":"2013/11/30/aenjon/Life/写在年末, 我的2013/","link":"","permalink":"http://aenjon.com/2013/11/30/aenjon/Life/写在年末, 我的2013/","excerpt":"","keywords":null,"text":"啰嗦好久没写博客了, 遗忘的历史,遗忘了自我… 岁月拾回,几度轮回…2013，奇妙的一年，糊涂的一年，说不清，理更乱… 从雄心壮志，斗志昂扬，到忙得一塌糊涂，到习惯麻木，而年末却极其清闲无聊，完全找不着自我，以至于能够静下心来好好回顾一年，好好规划即将开始之路…我的2013,这样走过… 身心 事业 能力/个人提升 家庭 价值 财富 写入历史 DEL， F5 By aenjon-2013aenjon cnBlogs 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2013/11/30/aenjon/Life/写在年末, 我的2013/","raw":null,"content":null,"categories":[{"name":"aenjon","slug":"aenjon","permalink":"http://aenjon.com/categories/aenjon/"},{"name":"Life","slug":"aenjon/Life","permalink":"http://aenjon.com/categories/aenjon/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"http://aenjon.com/tags/Life/"},{"name":"aenjon","slug":"aenjon","permalink":"http://aenjon.com/tags/aenjon/"}]},{"title":"织物疵点检测机器视觉系统 软件测试平台","slug":"CV/织物疵点检测机器视觉系统 软件测试平台","date":"2012-05-03T16:23:20.000Z","updated":"2016-12-08T00:28:06.000Z","comments":true,"path":"2012/05/04/CV/织物疵点检测机器视觉系统 软件测试平台/","link":"","permalink":"http://aenjon.com/2012/05/04/CV/织物疵点检测机器视觉系统 软件测试平台/","excerpt":"","keywords":null,"text":"啰嗦 之前针对个人研究的不同算法开发过三个检测平台（平台一 和 平台二 ），此平台为最后的综合平台，实现织物疵点检测和分类，实现了织物图像的批量化处理，实现了数据库存储疵点信息和用户管理，同时具备自动化测试的同时还可以进行单步算法调试。 开发环境开发工具采用VS2010+OpenCV，开发语言为CPP。OpenCV环境搭建 功能详述1 软件架构 该平台主要包括系统登录模块、图像采集模块、图像预处理模块、织物疵点检测模块、织物疵点分类模块、疵点信息管理模块、用户管理模块以及系统设置模块，检测算法为自主研究，分类算法采用BPNN，软件架构如下图所示 2 核心功能 该平台核心功能包括：织物疵点检测和分类，疵点信息存储和查询，用户管理等。 3 算法流程①系统设置，如下图所示 ②图像采集，图像的获取可以采取两种方式，单张图像加载或批量图像（文件夹）加载，在系统设置模块中的图像获取方式中，可选择设置单张图像的路径或者设置图像文件夹的路径来获取图像并实时显示, 如下图所示 ③图像预处理，如下图所示 ④织物检测和分类，如下图所示 ⑤织物信息查询，如下图所示 ⑥用户管理，如下图所示 实验测试针对常见的四类疵点，软件测试结果如下图所示： 项目工程及核心函数模块工程项目及核心处理函数模块如下图： Links【My Project】织物疵点检测机器视觉系统 平台一【My Project】织物疵点检测机器视觉系统 平台二关于显著性算法的实践效果请参考此文 By aenjon-2012aenjon cnBlogs合作联系：aenjon00@163.com 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2012/05/04/CV/织物疵点检测机器视觉系统 软件测试平台/","raw":null,"content":null,"categories":[{"name":"Tech","slug":"Tech","permalink":"http://aenjon.com/categories/Tech/"},{"name":"CV","slug":"Tech/CV","permalink":"http://aenjon.com/categories/Tech/CV/"}],"tags":[{"name":"CV/MV","slug":"CV-MV","permalink":"http://aenjon.com/tags/CV-MV/"},{"name":"DIP","slug":"DIP","permalink":"http://aenjon.com/tags/DIP/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://aenjon.com/tags/OpenCV/"},{"name":"图像算法","slug":"图像算法","permalink":"http://aenjon.com/tags/图像算法/"},{"name":"机器视觉","slug":"机器视觉","permalink":"http://aenjon.com/tags/机器视觉/"},{"name":"瑕疵检测","slug":"瑕疵检测","permalink":"http://aenjon.com/tags/瑕疵检测/"}]},{"title":"流媒体专题","slug":"Media/流媒体专题","date":"2012-04-10T16:30:20.000Z","updated":"2016-12-08T00:30:35.000Z","comments":true,"path":"2012/04/11/Media/流媒体专题/","link":"","permalink":"http://aenjon.com/2012/04/11/Media/流媒体专题/","excerpt":"","keywords":null,"text":"系列【流媒體】Android 实时视频采集/编码/传输/解码/播放—方案调研（初） 【流媒體】Android 实时视频采集—Cameara预览采集 【流媒體】Android 实时视频采集—MediaRecoder录制 【流媒體】H264—MP4格式及在MP4文件中提取H264的SPS、PPS及码流 【流媒體】 Android 实时视频编码—H.264硬编码 【流媒體】jrtplib—VS2010 下RTP开源协议库JRTPLIB3.9.1编译 【流媒體】live555—VS2010/VS2013 下live555编译、使用及测试 By aenjon-2012aenjon cnBlogs 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2012/04/11/Media/流媒体专题/","raw":null,"content":null,"categories":[{"name":"Tech","slug":"Tech","permalink":"http://aenjon.com/categories/Tech/"},{"name":"Media","slug":"Tech/Media","permalink":"http://aenjon.com/categories/Tech/Media/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://aenjon.com/tags/Android/"},{"name":"H264","slug":"H264","permalink":"http://aenjon.com/tags/H264/"},{"name":"jrtplib","slug":"jrtplib","permalink":"http://aenjon.com/tags/jrtplib/"},{"name":"live555","slug":"live555","permalink":"http://aenjon.com/tags/live555/"},{"name":"流媒体","slug":"流媒体","permalink":"http://aenjon.com/tags/流媒体/"}]},{"title":"图像算法专题","slug":"CV/图像算法专题","date":"2011-08-26T17:23:20.000Z","updated":"2016-12-08T00:28:37.000Z","comments":true,"path":"2011/08/27/CV/图像算法专题/","link":"","permalink":"http://aenjon.com/2011/08/27/CV/图像算法专题/","excerpt":"","keywords":null,"text":"系列 【图像算法】模板匹配 【图像算法】图像匹配 平台一 【图像算法】图像匹配 平台二 【图像算法】不变矩 【图像算法】图像特征：几何不变矩–Hu矩 【图像算法】图像特征：三个图像显著性区域特征提取方法上图我的算法最终效果： 【图像算法】图像特征：GLCM上图单个 GLCM以及4个方向的均值、方差GLCM特征： (彩色/灰度)图像像素值读取并保存到txt文件 By aenjon-2011aenjon cnBlogs合作联系：aenjon00@163.com 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2011/08/27/CV/图像算法专题/","raw":null,"content":null,"categories":[{"name":"Tech","slug":"Tech","permalink":"http://aenjon.com/categories/Tech/"},{"name":"CV","slug":"Tech/CV","permalink":"http://aenjon.com/categories/Tech/CV/"}],"tags":[{"name":"CV/MV","slug":"CV-MV","permalink":"http://aenjon.com/tags/CV-MV/"},{"name":"DIP","slug":"DIP","permalink":"http://aenjon.com/tags/DIP/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://aenjon.com/tags/OpenCV/"},{"name":"图像特征","slug":"图像特征","permalink":"http://aenjon.com/tags/图像特征/"},{"name":"图像算法","slug":"图像算法","permalink":"http://aenjon.com/tags/图像算法/"}]},{"title":"彩色图像分析软件 ColorImgSft V1.0.1.0","slug":"CV/彩色图像分析软件 ColorImgSft-V1.0.1.0","date":"2011-08-13T17:23:20.000Z","updated":"2016-12-08T00:28:58.000Z","comments":true,"path":"2011/08/14/CV/彩色图像分析软件 ColorImgSft-V1.0.1.0/","link":"","permalink":"http://aenjon.com/2011/08/14/CV/彩色图像分析软件 ColorImgSft-V1.0.1.0/","excerpt":"","keywords":null,"text":"开发环境 VC6.0+OpenCV1.0 软件界面用户登陆 完整界面 软件功能界面功能1 Picture Control 图像显示与保存 Source Image：源图像Dst Image：空间转换后图像(彩色)/目标彩色图像A channel：A通道图像(灰度)/目标灰度图像B channel：B通道图像C channel：C通道图像Save： 图像保存 2 Inf.Show 信息显示RunningTime： 法运行时间显示 -输出Threshold： 图像分割时阈值显示 -输出ClusterThred：颜色聚类分割阈值 -输入，默认0.12ClusterNum：颜色聚类数目显示 -输出ClusterNum：聚类数目显示(KCM) -输入，默认2 3 FetchColor 获取屏幕上任意点RGB/HSV/Lab/YIQ值FetchColor：打开/关闭按钮注：采用了定时器，故要进行其它操作时，最好关闭此按钮。 4 FindColor 查找SouceImage指定颜色说明：采用弹出式显示。分别代表原图上的原颜色、调整后的颜色、灰度值。 5 Button 按钮LoadPIC：加载图像Test：作者测试用，无效Quit：退出 6 SpaceChoose 空间转换SpaceCov：根据用户选择的颜色空间，执行空间转换 目录功能1 FileLoadPIC： 加载图像SavePIC： 保存DstImageQuit： 退出 2 EditCreatImage： 生成一张测试图片/作者图标注：必须先加载一张图片，初始化内存。 3 ViewFetchColor： 同界面FetchColor功能Dlg-SliderColor： 辅助作用–查RGB值与对应颜色关系WatchColours： 外部软件–功能同FetchColorImageInfo： 图像信息–图像大小、平均/最大/最小饱和度、平均/最大/最小亮度Histogram： 直方图GrayHist： 灰度直方图Dlg-GrayHist： 灰度直方图(对话框显示)Dlg-HSVHistSeg： HSV直方图分割ColorHist(RGB)： RGB直方图ColorHist(HS)： H-S直方图EqualizeHist： 直方图均衡化EqualizeHist(Gray)：直方图均衡化(灰度) 4 Image SpaceCov： 同界面SpaceCov功能ImgAdjust： 图像调整(彩色)ImageInvert： 图像反转RGB归一化： 图像RGB归一化EdgeDetect： 图像边缘检测(彩色&amp;灰度：彩色和灰度都适合)Sobel： Sobel边缘检测Laplace： Laplace边缘检测Canny： Canny边缘检测ImgSeg： 图像分割（彩色/灰度）GrayImgSeg： 灰度图像分割，有常见的六种分割方法ColorSegByHSV： 基于颜色提取的彩色分割(两种形式：定义范围不同)KCM： 根据输入的聚类类别数(默认2)进行K均值分割(彩色&amp;灰度)MeanShift： MeanShift彩色分割Watershed： 分水岭彩色分割HSVColorCluster：基于颜色聚类的彩色分割Morphology： 图像腐蚀/膨胀操作(彩色&amp;灰度：彩色和灰度都适合)Gabor： Gabor变换GaborFilter： 显示实/虚/模部Gabor滤波结果GaborTransfer： 显示最终Gabor滤波结果DWT： DWT变换SM： 图像显著性区域提取，包含三种不同的方法 5 Help About： 关于本软件信息Help：简要操作说明文档 操作实例空间转换 基于颜色聚类分割 基于颜色提取的分割 软件下载ColorImgSft1.0.1.0.zip 部分原理参考 By aenjon-2011aenjon cnBlogs合作联系：aenjon00@163.com 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2011/08/14/CV/彩色图像分析软件 ColorImgSft-V1.0.1.0/","raw":null,"content":null,"categories":[{"name":"Tech","slug":"Tech","permalink":"http://aenjon.com/categories/Tech/"},{"name":"CV","slug":"Tech/CV","permalink":"http://aenjon.com/categories/Tech/CV/"}],"tags":[{"name":"CV/MV","slug":"CV-MV","permalink":"http://aenjon.com/tags/CV-MV/"},{"name":"DIP","slug":"DIP","permalink":"http://aenjon.com/tags/DIP/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://aenjon.com/tags/OpenCV/"},{"name":"图像算法","slug":"图像算法","permalink":"http://aenjon.com/tags/图像算法/"},{"name":"彩色图像","slug":"彩色图像","permalink":"http://aenjon.com/tags/彩色图像/"}]},{"title":"彩色图像分割专题","slug":"CV/彩色图像分割专题","date":"2011-07-31T16:23:20.000Z","updated":"2016-12-08T00:29:17.000Z","comments":true,"path":"2011/08/01/CV/彩色图像分割专题/","link":"","permalink":"http://aenjon.com/2011/08/01/CV/彩色图像分割专题/","excerpt":"","keywords":null,"text":"系列【图像算法】彩色图像分割专题一：颜色空间1（原理) 【图像算法】彩色图像分割专题一：颜色空间2（部分结果） 【图像算法】彩色图像分割专题一：颜色空间3（部分源码） 【图像算法】彩色图像分割专题二：显示屏幕上任意点颜色值 【图像算法】彩色图像分割专题三：边缘检测+区域生长 法 【图像算法】彩色图像分割专题四：测试图片的生成 【图像算法】彩色图像分割专题五：提取彩色图像上特定色彩 【图像算法】彩色图像分割专题六：一种基于颜色直方图的图像分割 【图像算法】彩色图像分割专题七：基于分水岭的彩色分割 【图像算法】彩色图像分割专题八：基于MeanShift的彩色分割 【图像算法】彩色图像分割专题九：基于KCM的彩色分割 【图像算法】彩色图像分割专题十：彩色图像分析辅助软件 彩色图像分析辅助软件-MyCIS1.0.1.0 By aenjon-2011aenjon cnBlogs合作联系：aenjon00@163.com 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2011/08/01/CV/彩色图像分割专题/","raw":null,"content":null,"categories":[{"name":"Tech","slug":"Tech","permalink":"http://aenjon.com/categories/Tech/"},{"name":"CV","slug":"Tech/CV","permalink":"http://aenjon.com/categories/Tech/CV/"}],"tags":[{"name":"CV/MV","slug":"CV-MV","permalink":"http://aenjon.com/tags/CV-MV/"},{"name":"DIP","slug":"DIP","permalink":"http://aenjon.com/tags/DIP/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://aenjon.com/tags/OpenCV/"},{"name":"图像算法","slug":"图像算法","permalink":"http://aenjon.com/tags/图像算法/"},{"name":"彩色图像","slug":"彩色图像","permalink":"http://aenjon.com/tags/彩色图像/"}]},{"title":"那一年的“暑假书籍读后感”","slug":"aenjon/Life/那一年的“暑假书籍读后感”","date":"2010-09-11T16:23:23.000Z","updated":"2016-12-11T01:34:36.000Z","comments":true,"path":"2010/09/12/aenjon/Life/那一年的“暑假书籍读后感”/","link":"","permalink":"http://aenjon.com/2010/09/12/aenjon/Life/那一年的“暑假书籍读后感”/","excerpt":"","keywords":null,"text":"前言 这是一个读书期间的小故事。有些坎坷也有点伤感，那一年报考中科院自动化研究所败北，调剂到了华大，但科院之心不死，研一时通过应聘面试上了中科院的客座实习生，兴奋终于可以圆梦，可是跟导师沟通时被强制反对，然后那个暑假吵得有点伤感，这篇读后感是那个暑假导师的作业。 正文 闲散之余，这个暑假阅读了“胡雪岩的启示”、“孔子是怎么炼成的”、“易经的奥秘”，一个是中国商界奇才，一个是中国精神文化源地，易经则是中国哲学的根本，一切思想甚至科学的源泉。结合现实谈谈现在的一点感悟。 “为官须看曾国藩，为商必读胡雪岩”，记得初三毕业那年，读了一本近1000页的关于曾国藩的传记，年幼无知，并不懂得太多深刻的处世或为人道理，只是被情节所吸引，印象特别深的是其中的一对兄弟，兄为曾国藩手下将士，弟为洪秀全手下的悍将，两人偷偷见面的互相真诚规劝以及最后太平天国沦陷时，弟选择自杀而不接受兄的劝慰，我能体会到他兄弟俩的情感之真，这种情感并不像三国时诸葛亮兄弟那种勾心斗角而是一种感同身受后的坚定和互解，同时也能感悟到人生的抉择无所谓对错，选择了，就坚持自己的选择，人生苦短，几十年的生命生涯不能把太多的时间放在琐碎之事上，问心无愧，足矣！ 胡雪岩，研一的时候通过百家讲坛了解一二，当时由于时间原因并没有深入细读，只知道那是一个活生生的商业案例，从就业到创业再到败业，一路过来，造就了他辉煌的生命！这个暑假，心乱之余，权当舒心抑或任务，把曾仕强的“胡雪岩的启示”看了两遍，做了一些记录，收获了一些思想，也进一步了解了一些为人处世，经商之道。 所谓胡雪岩商训之天地人：天为先天之本，经商之本，地为后天修为，靠诚信立身，人为仁义，懂取舍，讲究君子爱财，取之有道；结识王有龄，面见左宗棠，再见西太后，每一次都是在充分准备中再有所行动；他那识人、识世的眼光；那为人诚信、一诺千金的人格；那借人，借物，借势的智慧；那随机应变的圆通…他留给了后世，也给了我很多思想和智慧，或好或坏，全在后世的应用。当然，或许这方面的领悟，会比较肤浅，毕竟离现在的自己还很远，不过正如傅佩荣所说：年轻时，我们需要疯狂的吸取知识，没有必要过多关注这些知识有没有用，在以后的人生之路上，自己再去慢慢反嚼，再去收获，再去感悟！ 观胡雪岩，印象最深的是在他从一个放牛娃在逐步发迹的过程中对机会、对人、对物的把握。从放牛娃 到 十三岁离家当学徒 到 二十七岁收获于老板的阜康钱庄 再 四十岁胡左联手、大展宏图 到 五十五岁建成一生基业胡庆余堂、达到人生最高峰 最后 六十二岁事业败落，郁郁而终。他的这一生的确是一个奇迹，时势造英雄，在那种乱世中也能出商界奇才，有时，有运，有命，更有他自己的智慧和汗水！ 在面对机会时，他的把握和态度，如“机会只垂青有准备的人…既然出来了，就要好好学，学到手的东西是自己的，学来的东西谁也偷不掉…一旦确定方向之后，就不要考虑有没有机会，而要做好自己能做的准备，等一切准备充足了，机会就自然水到渠成了…要抓住机会，要让别人了解你有什么本事…”在面对理想时，他如何去创造机会；在人生的路上，他是如何阶段性的做出合理的调整和选择，这些是我现在能体悟到的最深刻！ 正如今日开会郑老师所说，不能太以自我为中心，好好把握已有的机会，踏实的走好人生每一步，新的机会总会有的…很多人都有过辉煌的理想，但是有几个人真正实现了，大多数都失败了，学会适应社会… 对待环境，我一直的信念是：要么选择环境、要么改变环境、要么离开环境、千万不抱怨环境！这样的信念也一直促使自己做着一系列的抉择，所有的结果只能自己独自承担，不怨天、不怨地、也无须怨自己。知错、改错但不认错，或许这种态度是不对的，但伴随了自己很多年，或许对与错本来就没有标准，但如果你不能改变社会，你必须学会改变自己，学会适应社会，否则你只能被淘汰。茫茫沧海，你又算什么？你的存在难道要证明什么叫无知，能者都能很好的利用环境。暑假前在日记里写过这么一段话“一个人如果不能自已，连起码的真实的自我都不能做，其它一切又何从谈起？这个社会很混蛋，教唆者人们的所谓的为人处世，其实都是自私虚伪下的另一种表现形式。成王败寇，或许今天的我没有这样的资格，但这话我是说给明天的…”现在回思，我明白，正如孔子所说的忠恕之道，内在的本质的东西可以不变，但你应该学会在在适应环境下去谈自我，去发展自我，去实现自我。记住，如果你不改变自己，就会被淘汰！ 对待环境、对待机会的态度，这是我深悟的！ 孔子是怎么炼成的，讲述了孔子的一生及其思想。以孔子为代表的儒家思想一直占据着中国主流思想和精神，影响着一代又一代人的价值观和人生观，虽然，五四后的若些年有所减弱，但精神财富缺乏的现代、现在，再次重拾中华名族的宝贵财富。三十而立，人在一定的年龄阶段需要立定自己的德行和价值观，立定最基本、最根本的东西；四十不惑，不惑之年，用郑老师的话，这个时候才能明白很多人生的道理，确实，年轻是我们的资本，我们肆意的挥掠这种财富，老之将至时，才发现原来梦想或已成现实，或还留在童年，或迷失在成长的道路上，路是自己选择的，路也是自己走出来的，我一直是这样的观念，无论做什么样的抉择，坚持下去，不留悔恨在明天，不留遗憾在明天，但有时候，选择太多时，反而没的选择，舍得舍得，有舍才有得，反复告诉自己这样的话，希望自己能够真正明白。拥有奶酪就意味拥有幸福，但奶酪需要自己寻找，同时不要死抱着尘封的历史！ 易经中，我学到了关于变化的哲理。简单的问题复杂化，复杂的问题简单化，这种观点并不十分认同，但却告诉了我一个看待事物全面、对立统一和辩证的观点。任何东西达到最高点之后就会往下掉，谁也抵挡不了。物极必反。正如易经里所说：有生必有死，有盛必有衰，有起必有落，这是自然地道理。凡事过犹不及，事物都是循序渐进的，做人做事都有一个过程，事物本身各自的极端都会走向失败！同时也明白，人，是要自己负责的，God help this who help themselves，你能够帮助自己，所有万物都会来帮助你！ 中国的哲学思想：宇宙万物充满生命+人的生命需要实现价值。价值一直都是我追求和奋斗的目标以及做每一件事情的衡量标准，但是，也必须明白潜龙勿用的道理，不要把所有的事情都用价值来衡量，或许，人活在这世上，很多事情都是身不由己的，Sometimes we are doing the things we want to do，but most of the time we are doing the things we have to do. That is the truth，that is life，that you have to adapt it. 先做自己能够做的事情，再做自己应该做的事情，最后再做自己想做的和喜欢做的事情，在被利用和利用的过程总去磨练自我、提升自我。见龙在田，利见大人，机会来的时候要好好把握，学习胡雪岩，学会终日乾乾；在没有机会的时候，学习老俞，好好的积累自己的深度，等待机会，当然也可以创造机会！ 回顾自己走过的二十来年学生生涯，所谓人生，太多曲折和坎坷，多次成功与失败，起起伏伏，经历教训，错过/错失了好几个重要转折点自己。涂总所说的曲线救国，或许会是一种安慰。没有怨言，不会后悔，只有教训！如果有些东西都是人生中必须经历的，必须尝试的，必须失去的，真希望暴风雨来的更猛烈些，让一切苦难、一切挫折、一切坎坷，一切的一切，都来的更猛烈些吧，留更多的美好给明天！I am still a young man, but in the words of Scripture, the time has come to set aside childish things, the time has come to reaffirm my enduring spirit. 现实的一切经历、经验、教训都是人生的财富，月明不是孤人影，癫狂此生又如何，易经说：天行健，君子以自强不息；地势坤，君子以厚德载物。记住，永不磨灭！ 高考心态问题导致名落孙山，当年的点滴历历在目，永难忘怀，还清晰的记得当时的自己是多么的沮丧，封锁自己，十多天没有说一句话，吓坏了父母，没有傻，糊涂中明白着些什么，“苍天戏人人太仁”，写下这首诗后，从此不再写诗，最后在父母的规劝下，去了一所二本学校；圆梦洗辱报恩六个大字至今还刻在我那大学的书桌上，别人的不理解也正造就了大学的所谓的辉煌，大学过的很充实，学业知识、个人生活、科研实践，一切都那么顺利，曾仕强说：一个人太顺的时候，更需要格外小心，福兮祸之所依 祸兮福之所伏，大意留祸根验证着胡雪岩的最后结局，的确，大学的顺利使自己在拥有极强毅力和勤奋干劲的同时也养成了自我意识极强的个性，大学里面，所有的决定都是自己做，几乎所有的科目都是自学的，上不上课自己决定着，学什么样的知识也自己决定着，读研后，面对接连几次挫折和教训后才明白自己的命门，当然一切还来得及，需要的是更多的锻炼和磨练，It is never too later to do the right thing，when you know which it is. 易经告诉我们的就是在人生的各种境遇中应该如何把持住自己的心态，如何去做自我的选择，如何在人生的不同阶段作出阶段性的合理的调整，最后，坚持下去！ 同时，读研后才明白，你所处的环境决定了你的视野，井底之蛙永远不知道外面的天空有多大，仅拿技术来说，大二自学完数电、单片机，参加电子竞赛和挑战杯，再跟老师做项目，留在研究所的多少个日日夜夜已被记忆模糊，年轻气盛，永不满足，探究整个电信学院，探究搞实践项目的那几个老师，控制方面，就单片机、PLC等，后者偏强电，不感兴趣，于是探索新技术的学习。当时，网上了解到有个嵌入式ARM技术很火、同时还有一个老师的上位机编程看似很牛B、很高深，另外还有DSP，但听说算法很多，不感冒，最后在07年时给自己大学定下两个目标，其一是在上位机VC编程或ARM领域有所突破，其二是准备考研，洗高考之辱。当时以为掌握好VC和ARM，这辈子技术就可以告一段落，可以称得上所谓牛B，可以开始人生转型，读研后，才明白，无止尽的技术是一辈子都无法学尽的，读完一篇清华大学博士的退学感思后，这种认识更加清晰，再加之个人从电信学院到计算机学院的这种转业，视野开阔了却也迷糊了。庄子所云：吾生也有涯，而知无涯，以有涯而随无涯，怠已。后面深刻明白一个道理，也如曾仕强在总结胡雪岩把握机会的智慧中所说：人生，其实抓住基本的东西就足够了。 而后，考研再度失利，涉及情感方面不便多说。调剂到华大后，第一学期适应新的环境、接受新领域知识，结识新朋友，活的比小学生还单纯或潇洒。去年寒假，在给自己定规划2010年时，决定一定要在2010年干一番事，做出一番成就，2010必须作为自己人生中重要转折的一年，必须写入历史。一个学期过去，也兼职工作了一个学期，很累却没有成就，反而各种琐事影响着自己的心态，在上学期期末时，做了几个决定，每一个决定都有点唐突，往事不堪回首。。。现在，2010过了一大半，前者没有实现，后者反倒实现了，太多的经历，太多的心灵坎坷，太多的东西扭曲着自己，迷失者自我，在挣扎抵抗反思中不断的调整，暮然回首，才发现，其实你要做的，仅仅是改变自己，改换心态，正如前面所言，如果你不能适应环境，你就会被淘汰。淘汰抑或堕落不是我的性格，我知道，人生的低谷只有自己才能够走出，我明白自己想要什么，迷失也只会是暂时，喜欢上了刘欢的一首歌，从头再来！Try Again！Start Over！ 曾仕强说：与其早成功，不如晚成功；与其晚失败，不如早失败。未来是自己创造出来的。每个人对自己所作所为都要负起全部的责任。永远抱着这样的意识去做事，做每一件事，后果自己都要全部承受。 “不怨天不尤人”。命运掌握在自己手中，未来是自己创造出来的，我会对自己所作所为负全部责任。同时，尽人事听天命，人可以掌握过程，但是不可以控制结果。只问耕耘不问收获，人只应该为自己能控制的部分而努力。任何存在的事情都有其价值，有过的经历经验教训得失，都成为人生的宝贵财富，端正自我，才能更好的提升自我！有些事，需要到一定的年龄阶段、一定的事业阶段、一定的人生高度之后，你才能去做的！ 读书，是为了自己，是为了明白道理，结合经历，形成一个阶段的感悟~~ God, grant me the Serenity to accept the things I cannot change,Courage to change the things I can,and the Wisdom to know the difference.Living one day at a time;Enjoying one moment at a time;Accepting hardship as the pathway to peace. –By Reinhold Niebuhr aenjon 9/11/2010 HQU XiaMen China 注：Send to Boss 9/12/2010 By aenjon-2010aenjon cnBlogs 版权声明 aenjon by aenjon is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Bob创作并维护的aenjon博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证.本文首发于aenjon博客（ http://aenjon.com ），版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 微信扫码打赏aenjon 如果您愿意捐助其它金额请戳我~~，扫码支付宝/微信 本文永久链接：http://aenjon.com/2010/09/12/aenjon/Life/那一年的“暑假书籍读后感”/","raw":null,"content":null,"categories":[{"name":"aenjon","slug":"aenjon","permalink":"http://aenjon.com/categories/aenjon/"},{"name":"Life","slug":"aenjon/Life","permalink":"http://aenjon.com/categories/aenjon/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"http://aenjon.com/tags/Life/"},{"name":"aenjon","slug":"aenjon","permalink":"http://aenjon.com/tags/aenjon/"}]}]}